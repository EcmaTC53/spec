<p></p>
<p id="subtitle">TC53 DRAFT / November 18, 2020</p>
<p id="title">ECMAScript® Modules for Embedded Systems</p>

<img src="../web/assets/ecma-logo.svg">

## Introduction

This standard, ECMAScript Modules for Embedded Systems, defines APIs for use on embedded systems. Embedded systems are far more diverse than personal computers, smartphones, and web servers where ECMAScript is most widely used. The diversity of embedded hardware is a consequence of devices being optimized for a specific product or class of products.

It is not enough for these APIs to support the features embedded systems have in common. To be truly useful, they must allow access to the unique hardware capabilities of each embedded system. This requirement makes this standard very different from that of a computer language which is grounded in the formality and rigor of mathematics. Hardware can be inconsistent, even sometimes messy, but it needs to be accommodated. 

The ability for scripts to access unique hardware capabilities has an important consequence. It means that not all correct scripts will run correctly on all hardware. If a script requires a feature that is unavailable, it cannot run. While it is common in ECMAScript to emulate missing language and runtime features with a "polyfill", this is usually impractical, if not impossible, for hardware capabilities. Therefore, the goal of this standard is to make it possible to write portable scripts for specific operations, not to guarantee that all scripts execute correctly on any conformant deployment.

One important consideration when designing hardware products is cost. The APIs are designed to allow efficient execution with minimal resource use. They assume no minimum or maximum configuration. Advances in the state-of-the-art of ECMAScript engines, microcontrollers, and runtime libraries will determine where these APIs may be used.

This standard is influenced by the [Extensible Web Manifesto](https://github.com/extensibleweb/manifesto#the-extensible-web-manifesto). It aims to provide low-level APIs that do things — primarily related to hardware and communication — that the ECMAScript language cannot do by itself. These low-level APIs are functional, simple, and efficient. The APIs may be used directly. However, it is expected that many developers will interact with them indirectly through higher-level modules and frameworks that build upon the low-level APIs. This layered approach keeps the low-level APIs small and focused while allowing a variety of uses and API styles to be built upon them.

## 1 Scope

This standard defines application programming interfaces (APIs) for ECMAScript modules that support programs executing on embedded systems.

This standard defines APIs for capabilities found in common across embedded systems. Implementations for embedded systems that include additional capabilities are encouraged to provide ECMAScript APIs for those using the many extensibility options provided by this standard.

This standard does not make any changes to the ECMAScript language as defined by ECMAScript Language Specification (ECMA-262). It does strongly encourage all deployments to execute only in strict-mode. It recommends using the Secure ECMAScript proposal for embedded systems that require secure execution of scripts. 

## 2 Conformance

A conforming implementation of the ECMAScript Modules for Embedded Systems standard must conform to ECMA-262 and must provide and support all the objects, properties, functions, and program semantics required by this specification.

A conforming implementation of the ECMAScript Modules for Embedded Systems standard is permitted to provide additional objects, properties, and functions beyond those described in this specification.

In particular, a conforming implementation of this standard is permitted to provide properties not described herein, and values for those properties, for objects that are described in this specification. A conforming implementation is permitted to add optional arguments to the functions defined in this specification only where noted. 

Because implementation differences are permitted (for example, to accommodate differentiating hardware features), this standard does not guarantee that all scripts execute correctly on every conformant deployment.
 
Self-hosted implementations are permitted as long as they conform to the requirements of this standard (for example, ensuring internal properties are not visible). 

## 3 Normative references

The following referenced documents are required for the application of this document. For dated references, only the edition cited applies. For references without a date or version number, the latest edition of the referenced document (including any amendments) applies.

- ECMA-262, *ECMAScript Language Specification*. <br>[https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
- ECMA-402, *ECMAScript Internationalization API*. <br>[https://www.ecma-international.org/publications/standards/Ecma-402.htm](https://www.ecma-international.org/publications/standards/Ecma-402.htm)
  
## 4 Terms and definitions

For the purposes of this document, the following terms and definitions apply.

##### Address
An identifier for interfacing with a specific component, device, or board.

##### Baud rate
The rate at which information is transferred, measured in bytes per second.

##### Bus
A communications system that transfers data. A "Bus" includes hardware, software, and the protocol.

##### Expander
A device that provides additional inputs and/or outputs.

##### Instance
An object that has been created by a function constructor, class constructor, or function factory.

##### MCU
See **microcontroller**.

##### Microcontroller
A single integrated circuit with one or more CPUs, memory, and programmable input/output.

##### Protocol
A system of rules that define how data is exchanged between systems.
    
##### Register
Locations in a device's memory which can be written to or read from. These memory locations may contain configuration settings or the current state of the device.

##### Sensor
A device that detects and responds to some type of input from the physical environment. 

## 5 Notational conventions

TBD

## 6 Overview

### ECMAScript

This standard builds on Standard ECMAScript as defined by Ecma TC39. As of this writing, that is ECMAScript 2020.

This standard is not an extension or subset of ECMAScript 2020. It is a set of APIs to be used within that standard. The relationship between ECMA-xxx and ECMAScript is analogous to the relationship between ECMA-402 (ECMAScript Internationalization API) and ECMAScript.

This standard is intended to be used in strict mode only. Sloppy mode has known issues that detract from building a robust system. Sloppy mode is maintained primarily for web compatibility and provides no benefit to embedded systems.

### Class patterns

A Class Pattern, as used in this standard, is a combination of requirements and guidelines for a class. For example, the IO Class Pattern defines behaviors for all IO classes.

The standard defines classes in terms of Class Patterns. In the future, there may be true formal classes as found in the ECMAScript Language.

The requirements of a Class Pattern are behaviors defined by this standard and must be adhered to for a conformant implementation. A Class Pattern can be seen as similar to a collection of Abstract Operations in the ECMA-262.

Guidelines are primarily for extensibility. Extensibility is essential to this standard as it must be possible to access unique hardware capabilities. Extensibility is problematic because of the potential for collisions. This standard provides requirements for how extensibility may be implemented.

Unless stated, there are no requirements about class inheritance. An implementation of a class pattern may inherit from `Object` or any other class, so long as it conforms.

### Independent implementations

This standard is intended to facilitate multiple independent implementations of the APIs. A given API may warrant an entirely different implementation depending on a variety of factors that include the host hardware, operating system, and ECMAScript engine.

### Self-hosting

The ECMAScript language is defined in terms of a host that provides the runtime environment for the execution of scripts. This standard does not change that. The APIs defined herein are provided by a host. However, this standard does anticipate that portions of the runtime environment provided by the host may themselves be implemented in ECMAScript. This standard refers to a host that includes some ECMAScript code in its implementation as self-hosting.

One challenge of self-hosting is keeping the host fully separated from the scripts, to avoid problems including security, robustness, and compatibility. The Compartment model defined as part of the Secure ECMAScript proposal provides a solution for separating host scripts and hosted scripts.

Self-hosted implementations must ensure that no internal properties or methods are visible to client scripts using the implementation. Private fields and private methods are a way to shield internal properties and methods from client code, but their use is not required.

> **Note:** Self-hosting is not required.

<!--
### Immutability

Immutability of object properties is a feature of ECMAScript. It is not widely used, however. Immutability is valuable for embedded systems and consequently, this standard makes use of it in several ways.

- Data may be stored in read-only memory, reducing the RAM required for execution
- Improving security as they are inherently resistant to tampering
- Simplifying implementation, as in...

-->

### Module specifiers

This standard defines classes which are accessed through modules. Because many embedded systems lack a file system, using file paths to access modules is impractical and contrived. Instead, modules are accessed using bare module specifiers. While such specifiers are currently forbidden in a web browser, they are permitted in other environments.

A namespace prefix is used to minimize the chance of name collisions with other bare module specifiers. This standard uses the namespace prefix `tc53:` (this prefix is a placeholder).

	import Digital from "tc53:io/digital";

The use of module namespaces in this standard is intended to be compatible with the [Built In Modules Proposal](https://github.com/tc39/proposal-built-in-modules#namespace).

For the avoidance of doubt, the use of bare module specifiers by this standard does not prevent a host from also supporting other kinds of module specifiers.

### Secure ECMAScript

Secure ECMAScript (SES) is a proposal to extend the ECMAScript language to support provably secure execution of scripts in an environment that includes both trusted and untrusted scripts. The two foundations of Secure ECMAScript are immutability and compartments. SES makes all primordials immutable prior to the execution of any untrusted script code. This ensures built-in objects behave as defined by the language, disables common attack vectors, and eliminates communication side-channels. Compartments allow scripts to sandbox other scripts to limit the globals and modules that are available in the sandbox.

The security guarantees provided by SES are valuable for building large systems that contain code from many sources, not all of which may be fully trusted. The mechanisms proposed by SES allow for an efficient implementation. Further, the immutability requirement for SES allows primordials to be stored in read-only memory, reducing RAM use and enabling them to be securely shared by multiple virtual machines.

This standard is designed to be used with SES when a runtime security solution is required. If and when the SES proposal is an approved standard, this standard will reference it normatively.

SES consists of two major execution phases — pre-lockdown and post-lockdown. Prior to lockdown, primordials are mutable and compartments are unavailable. A host is not required to support pre-lockdown on an embedded system. A host may complete lockdown during the build process, for example.

### Naming

This standard uses the lower camel case naming convention (e.g. `exampleProperty`) for property names.

It follows the ECMAScript convention of naming classes with upper camel case (e.g. `ExampleClass`) and methods with lower camel case (e.g. `exampleMethod`).

Callback function names begin with `on` (e.g. `onExampleCallback`).

Words are preferred over abbreviations and acronyms (e.g. `address` instead of `addr`, `clock` instead of `scl`, `receive` instead of `rx`), though common acronyms are acceptable.


## 7 Requirements for standard built-in ECMAScript objects

Unless specified otherwise in this document, the objects, functions, and constructors described in this standard are subject to the generic requirements and restrictions specified for standard built-in ECMAScript objects in ECMA-262, 10th edition, clause [17](https://tc39.es/ecma262/#sec-ecmascript-standard-built-in-objects), or successor. 

## 8 Base Class Pattern

The Base Class Pattern defines common behaviors used by other class patterns. The Base Class Pattern is purely abstract and cannot be instantiated directly.

Classes conforming to the Base Class Pattern may be subclassed.

### `constructor`

The constructor of the Base Class Pattern takes an options object as its first argument.

The `target` property is the only property the Base Class Pattern defines in the options object. 

Typically there are no other arguments as additional configuration options can and should be added to the options object. However, additional arguments are not prohibited.

It is an error to invoke the constructor without the options object. An exception will be thrown.

The implementation of the constructor should validate all supported option properties before allocating any resources. This behavior avoids enabling or changing the state of any hardware should the constructor fail due to invalid parameters.

The implementation must ignore any unrecognized properties on the options object.

If the constructor fails to complete execution successfully, it must release any resources allocated prior to exiting.

The constructor must not modify the options object. It must accept an immutable options object.

Once the instance has been successfully constructed, it must not be eligible for garbage collection until it is explicitly released by calling `close`. This is done so scripts do not need to maintain a reference to the object to prevent it from being collected, similar to `setInterval`/`clearInterval` and the W3C Generic Sensor specification.

### `close` method

The `close` method releases all resources associated with the instance.

Once `close` completes, the object is eligible for garbage collection.

Once `close` completes, an `Error` exception is thrown if any other instance methods are called. (Note: should a better error be defined for this?) It is not an error to call the `close` method more than once.

No callbacks may be invoked after the `close` method is called.

### `target` property

The `target` property is opaque to the object's implementation. It may be initialized by the constructor using the `target` property in the options object. Scripts may both read and write the target property, though it is typically only set at construction.

### Callbacks

Instances of the Base Class Pattern typically use function callbacks to deliver asynchronous events. 

Callback functions are provided to the instance as properties in the options object. 

	new Button({
		onPush() {
		},
		onRelease() {
		}
	});

Callback functions are invoked with `this` set to the instance. This can be overridden using standard ECMAScript features, such as arrow functions:

	new Button({
		onPush: () => {
		},
		onRelease: () => {
		}
	});

The callbacks are stored internally by the implementation. They are not public methods. The callback functions cannot be read and are only set using the constructor's options object. 

A callback function may only be invoked when no script is running in its host virtual machine to respect the [single-thread evaluation semantics of ECMAScript](https://tc39.es/ecma262/#sec-happens-before). This means that callbacks may not be invoked by the instance from within its public method calls, including the constructor.

Callbacks must be invoked in the same virtual machine in which they were created. 

## 9 IO Class Pattern

The IO Class Pattern builds on the Base Class Pattern to provide a foundation for implementing access to a variety of hardware inputs and outputs.

All IO is non-blocking, consistent with ECMAScript API behavior on the web platform. That said, not all operations are instantaneous. Implementations determine how long is too long for a given operation.

Non-blocking IO is facilitated by two callback functions, `onReadable` and `onWritable`, which eliminate the need for polling in most cases.

### Pin specifier
A **pin specifier** is a JavaScript value used by IO classes to refer to hardware connections represented by pins. Typically these pins correspond to a particular connection point on the hardware package, although this is not required.

The value of a pin specifier is host-dependent. It is often a number corresponding to the logical GPIO pin number as per the hardware data sheet (e.g. GPIO 5), but it may be a string ("D1") or even an object ({port: 1, pin: 5}).

### constructor

The options object contains the specification of the hardware resources to be used by the instance. For example, the digital class indicates the physical pin to use with a `pin` property that has a pin specifier value.

If the constructor requires a resource that is already in use — whether by a script or the native host — an `Error` exception is thrown.

This standard allows but does not require, an implementation to open multiple instances for the same hardware resource if the instances cannot interfere with each other's operation. For example, this can work for a digital input but would not for a digital output.

The IO Class Pattern is designed to be used both with IO types that have only a current value (e.g. Digital, analog, PWM) and IO types that use streams of data (e.g. serial, SPI).

The IO Class Pattern reserves the `io` property name in the options object. If present, it must be ignored by IO implementations.

### `read` method

The `read` method returns data from the IO instance. If no data is available, it returns `undefined`.  The type of the data returned depends on the value of the `format` property.

The `read` method may take any number of arguments, including zero. The arguments are defined by the specific IO type.

If the instance does not support reading (because the IO type is inherently unreadable or because it is configured for write-only) an exception is thrown.

### `write` method

The `write` method sends data to the IO instance.

The following conditions cause an `Error` exception to be thrown: the device cannot accept the data because its buffers are full, the data is incompatible, or a hardware error.

The `write` method may take any number of arguments, including zero. The arguments are defined by the specific IO type. The type of data accepted by `write` depends on the value of the `format` property.

If this instance does not support writing (because the IO type cannot be written or because it is configured for read-only) an `Error` exception is thrown.

### `format` property

The `format` property is a string that indicates the type of data used by the `read` and `write` methods. It is initialized by the constructor to the default defined for its IO type. The `format` property may be set by the script at any time to change how it reads and writes data.

The following values are defined by the IO Class Pattern for the `format` property. IO types may choose to support one or more and may define others.

- `number` - an ECMAScript number value, typically used for bytes
- `buffer` - an `ArrayBuffer` instance
- `object` - an ECMAScript object, for data representing a data structure (e.g. JSON)
- `string;ascii` - an ECMAScript string, for reading from and writing to IO using 7-bit ASCII data
- `string;utf8` - an ECMAScript string, for reading from and writing to IO using UTF-8 formatted data

The `format` property is implemented as a getter and setter. Attempting to set the `format` property to an unsupported value does not change the value and instead throws an `Error` exception.

### Callbacks

The IO Class Pattern specifies three callbacks which are set by the options object passed to the constructor. Most IO types operate with or without these callbacks installed, but a particular IO type may require one or more callbacks.

#### onReadable

The `onReadable` callback is invoked when the instance has data available to be read. Data is retrieved using the `read` method.

The `onReadable` callback may receive one or more arguments with information about the data available to read. The arguments are defined by the specific IO type.

The `onReadable` callback is invoked once when data arrives and not again until additional data is available to read.

#### onWritable

The `onWritable` callback is invoked when the instance is able to accept more data for output.

The `onWritable ` callback may receive one or more arguments with information about the amount of data that may be written. The arguments are defined by the specific IO type.

#### onError

The `onError` callback is invoked when a non-recoverable error occurs. The instance is no longer usable. The only method that should be called is `close`.

Details of the error may be passed to the callback using arguments defined by the specific IO type.

## 10 IO classes

This section defines IO Classes conforming to the IO Class Pattern.

The classes support capabilities commonly supported by hardware and runtimes. Capabilities that are not supported here may be added using the extensibility options of the IO Class Pattern and Base Class Pattern.

### Digital

The `Digital` IO class is used for digital inputs and outputs.

```js
import Digital from "tc53:io/digital";
```

#### Properties of constructor options object

| Property | Description |
| :---: | :--- |
| `pin` | A pin specifier indicating the pin to control. This property is required. |
| `mode` | A value indicating the mode of the IO. May be `Digital.Input`, `Digital.InputPullUp`, `Digital.InputPullDown`, `Digital.InputPullUpDown`, `Digital.Output`, or `Digital.OutputOpenDrain`. This property is required. |
| `edge` | A value indicating the conditions for invoking the `onReadable` callback. Values are `Digital.Rising`, `Digital.Falling`, and `Digital.Rising | Digital.Falling`. This value is required if the `onReadable` property is present and ignored otherwise. |

#### Callbacks

**`onReadable()`**

Invoked when the input value changes depending on the value of the `mode` property.

#### Data format
The `Digital` class data format is always `number` with a value of either 0 or 1.

#### Notes
A digital IO instance configured as an input does not implement write; one configured as an output does not implement read.

### DigitalBank
The `DigitalBank` class provides simultaneous access to a group of digital inputs or outputs.

```js
import DigitalBank from "tc53:io/digitalbank";
```

#### Properties of constructor options object

| Property | Description |
| :---: | :--- |
| `pins` | A bitmask with pins to include in the bank set to 1. This property is required.
| `mode` | A value indicating the mode of the IO, May be `Digital.Input`, `Digital.InputPullUp`, `Digital.InputPullDown`, `Digital.InputPullUpDown`, `Digital.Output`, or `Digital.OutputOpenDrain`. All pins in the bank use the same mode. This property is required.
| `rises` | A bitmask indicating the pins in the bank that should trigger an `onReadable` callback when transitioning from 0 to 1. When an `onReadable` callback is provided, at least one pin must be set in `rises` and `falls`.
| `falls` | A bitmask indicating the pins in the bank that should trigger an `onReadable` callback when transitioning from 1 to 0. When an `onReadable` callback is provided, at least one pin must be set in `rises` and `falls`.

#### Callbacks

**`onReadable(triggers)`**

Invoked when the input value changes depending on the value of the `mode`, `rises`, and `falls` properties. The `onReadable` callback receives a single argument, `triggers`, which is a bitmask indicating each pin that triggered the callback with a 1.

#### Data format
The `DigitalBank` class data format is always `number`. The value is a bitmask. On a read operation, any bit positions that are not included in the `pins` bitmask are set to 0.

> **Note:** This requirement prevents leaking the state of pins unused by this bank.

#### Notes
A digital IO bank instance configured as an input does not implement write; one configured as an output does not implement read.

### Analog input
The `Analog` IO class represents an analog input source.

```js
import Analog from "tc53:io/analog";
```

#### Properties of constructor options object

| Property | Description |
| :---: | :--- |
|  `pin` | A pin specifier indicating the analog input pin. This property is required.
|  `resolution` | The requested number of bits of resolution of the input. This property is optional.

#### Data format
The `Analog` class data format is always a number. The value returned is an integer from 0 to a maximum value based on the resolution of the analog input.

#### `resolution` property
The read-only `resolution` property indicates the number of bits of resolution provided in values returned by the instance.

### Pulse-width modulation
The `PWM` IO class provides access to the pulse-width modulation capability of pins.

```js
import PWM from "tc53:io/pwm";
```

#### Properties of constructor options object

| Property | Description |
| :---: | :--- |
|  `pin` | A pin specifier indicating the pin to operate as a PWM output. This property is required.
|  `hz` | A number specifying the requested frequency of the PWM output in Hz. This property is optional.

#### Data format
The `PWM` class data format is always a number. The `write` call accepts integers between 0 and a maximum value based on the resolution of the PWM output.

#### `resolution` property
The read-only `resolution` property indicates the number of bits of resolution in values passed to the `write` method.

#### `hz` property
The read-only `hz` property returns the frequency of the PWM.

#### Notes
A PWM instance defaults to a duty cycle of 0% until `write` is called with a different value.

### I²C
The `I2C` class implements an I²C Initiator to communicate with an I²C Peripheral over I²C bus.

```js
import I2C from "tc53:io/i2c";
```

#### Properties of constructor options object
| Property | Description |
| :---: | :--- |
| `data` | Pin specifier for the I²C data pin. This property is required.
| `clock` | Pin specifier for the I²C clock pin. This property is required.
| `hz` | The speed of communication on the I²C bus. This property is required.
| `address` | The 7-bit address of the target I²C Peripheral to communicate with. This property is required.

#### Data format
The `I2C` class data format is always buffer. The `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.

#### Specifying stop bit with `read` and `write` methods
The I²C protocol is transaction-based. At the end of each read and write operation, a stop bit is sent. If the stop bit is 1, it indicates the end of the transaction; if 0, it indicates that the transaction has additional operations pending.

The `read` and `write` methods set the stop bit to 1 by default. An optional argument to the `read` and `write` methods allows the stop bit to be specified. Pass `false` to set the stop bit to 0, and `true` to set the stop bit to 1. 

#### Methods
**`read(count[, stop][, buffer])`**
The first argument to the `read` method is a `Number` indicating the number of bytes to read. The result is an `ArrayBuffer` with a `byteLength` of that number of bytes. The optional second argument is a Boolean specifying the stop bit behavior.

An optional third argument (or second, if the stop bit `Boolean` is not present) is an `ArrayBuffer` to store the result of the read. If this argument is not provided, a new ArrayBuffer is allocated and returned. If the buffer is smaller than the number of bytes to read, an exception is thrown. If the buffer is larger, the bytes beyond the bytes to read are unchanged.

**`write(buffer[, stop])`**
The first argument to the `write` method is a buffer.  All the bytes in the buffer are written. An optional second argument is a `Boolean` specifying the stop bit behavior.

### System management bus (SMBus)
The `SMBus` class extends the `I2C` class with additional methods to communicate with devices that implement the SMBus protocol.

```js
import SMBus from "tc53:io/smbus";
```

#### Properties of constructor options object
| Property | Description |
| :---: | :--- |
| `stop` | A boolean value indicating whether to set the stop bit when writing the SMBus register number. This property is optional and defaults to `false`.

#### Methods
**`readUint8(register)`**

Reads and returns an unsigned 8-bit integer value from the specified register.

**`writeUint8(register, value)`**

Writes the unsigned 8-bit integer `value` to the specified register.

**`readUint16(register[, bigEndian])`**

Reads and returns an unsigned 16-bit integer value from the specified register. By default, the value is read in little-endian byte order. If the optional `bigEndian` argument is `true` the value is read in big-endian byte order.

**`writeUint16(register, value[, bigEndian])`**

Writes the unsigned 16-bit integer value to the specified register. By default, the value is written in little-endian byte order. If the optional `bigEndian` argument is `true` the value is written in big-endian byte order.

**`readBuffer(register, buffer)`**

Reads a stream of bytes starting at the specified `register` into the `ArrayBuffer` instance in the `buffer` argument. The number of bytes read is equal to the `byteLength` of the buffer.

**`writeBuffer(register, buffer)`**

Write a stream of bytes from the `ArrayBuffer` instance in the `buffer` argument starting at the specified `register`. The number of bytes read is equal to the `byteLength` of the buffer.

> **Note**: The SMBus standard also defines 32 and 64-bit operations. The method names `readUint32`, `writeUint32`, `readUint64`, and `writeUint64` are reserved to support these in the future. 

### Serial
The `Serial` class implements bi-directional serial (UART) communication.

```js
import Serial from "tc53:io/serial";
```

#### Properties of constructor options object
| Property | Description |
| :---: | :--- |
|  `receive` | Pin specifier for the receive pin. This property is required when using the serial connection to read data.
|  `transmit` | Pin specifier for the transmit pin. This property is required when using the serial connection to write data.
| `baud` | A number specifying the baud rate of the connection. This property is required.

If both `receive` and `transmit` are unspecified, a `TypeError` is thrown by the constructor during validation.

> **Note**: The serial connection is eight data bits, no parity bit, and one stop bit (8N1). The property names `parity`, `stop`, and `data` are reserved to support other communication configurations in the future.

#### Methods

**`read([byteLength])`**

When using the `number` data format, read always returns the next available byte as a `Number` (from 0 to 255).

When using the `buffer` data format, calling `read` with no arguments returns one or more bytes (implementation dependent). If the `byteLength` argument is provided, that number of bytes is returned in an `ArrayBuffer` unless fewer bytes are available, then only the bytes available are returned.

If no data is available, `read` returns `undefined`.

The `read` method never waits for additional bytes to arrive.

**`write(data)`**

When using the `number` data format, the `data` argument is a byte value to transmit. If the output buffer is full, `write` throws.

When using the `buffer` data format, the `data` argument is an `ArrayBuffer` or `TypedArray` containing one or more bytes to transmit. If the output buffer cannot accept all the bytes in the buffer, an exception is thrown -- partial data is never written.

**`flush([input, output])`**

Flushes the input and/or output queues of the serial instance. If no arguments are passed, both input and output queues are flushed. If both arguments are provided, the corresponding queues are flushed based on the value of the arguments. An exception is thrown if one argument is passed.

**`set(options)`**
The `set` method controls the value of the RTS and DTR pins of the serial connection together with the break. The sole argument is an options object which contains optional `dtr`, `rts`, and `break` properties with boolean values.

If `dtr`, `rts`, or `break` is not specified in the dictionary, the corresponding serial behavior is left unchanged.

<!--
**`get(options)`**

-->

#### Callbacks

**`onReadable(bytes)`**

The `onReadable` callback is invoked when new data is available to read. The callback receives a single argument that indicates the number of bytes available.

**`onWritable(bytes)`**

The `onWritable` callback is first invoked when the serial instance is ready for use.

The `onWritable` callback is invoked when space has been freed in the output buffer. The callback receives a single argument that indicates the number of bytes that may be written without overflowing the output buffer.

#### Data format
The `Serial` class data format is either `number` for individual bytes or `buffer` for groups of bytes. The default data format is `number`. When using the `buffer` format, the `write` call accepts an `ArrayBuffer` or a `TypedArray`, and the `read` call always returns an `ArrayBuffer`.

### Serial Peripheral Interface (SPI)

The `SPI` class implements a Serial Peripheral Interface (SPI) controller to communicate with a single SPI peripheral.

```js
import SPI from "tc53:io/spi";
```

#### Properties of constructor options object
| Property | Description |
| :---: | :--- |
|  `out` | Pin specifier for the Serial Data Out pin. This property is required when using the SPI bus to write data.
|  `in` | Pin specifier for the Serial Data In pin. This property is required when using the SPI bus to read data.
|  `clock` | Pin specifier for the clock pin. This property is required.
|  `select` | Pin specifier for the chip select pin. This property is optional and should not be specified if chip select will be managed by the caller.
|  `active` | The value to write to the `select` pin when the SPI instance is active. Must be 1 or 0. This property is optional and defaults to 0. 
|  `hz` | The speed of communication on the SPI bus. This property is required.
|  `mode` | The SPI bus mode, a two-bit mask that specifies the SPI clock polarity (bit 1) and phase (bit 0). This property is optional and defaults to 0b00.

If both `out` and `in` are unspecified, a `TypeError` is thrown by the constructor during validation. 

The `in` and `out` properties may refer to the same physical pin (e.g. 3-wire SPI).

#### Data format
The data format for the `SPI` class is always a buffer. The `read`, `write` and `transfer` calls accept an `ArrayBuffer` or a `TypedArray`. The `read` and `transfer` calls always return an `ArrayBuffer`. 

#### Methods

**`read(buffer)`**

Read `buffer.byteLength` 8-bit bytes from the SPI bus into `buffer` and return `buffer`. The behavior of the Serial Data Out pin is implementation-dependent.

If the `buffer` argument has a `bitLength` property, it specifies the number of bits to read, overriding the `byteLength` property to allow reading of partial bytes. `buffer.bitLength` must be less than or equal to the number of bits in the buffer (i.e. `buffer.byteLength * 8`). Bits are read into the start of `buffer` (i.e. bit offset zero).

**`write(buffer)`**

Write `buffer` to the SPI bus. Any input data is discarded.

If the `buffer` argument has a `bitLength` property, it specifies the number of bits to write, overriding the `byteLength` property to allow writing of partial bytes. `buffer.bitLength` must be less than or equal to the number of bits in the buffer (i.e. `buffer.byteLength * 8`). Bits are written from the start of  `buffer` (i.e. bit offset zero).

**`transfer(buffer)`**

Write `buffer` to the SPI bus while simultaneously reading `buffer.byteLength` 8-bit bytes from the SPI bus. The results of the read are placed into `buffer`, replacing the original contents, and returned.

If the `buffer` argument has a `bitLength` property, it specifies the number of bits of the buffer to swap in the transfer, overriding the `byteLength` property to allow transfer of partial bytes. `buffer.bitLength` must be less than or equal to the number of bits in the buffer (i.e. `buffer.byteLength * 8`). Bits are transferred from the start of `buffer` (i.e. bit offset zero).

**`flush([deselect])`**

Flushes any buffers of the SPI controller instance. The flush operation is synchronous and completes before returning.

Some SPI peripherals require that the chip select pin be set inactive at specific times (for instance, to mark the end of a transaction). The `flush` method supports this with the optional `deselect` argument which, when present and `true`, causes the chip select pin to be set to inactive after the flush completes.

### Pulse count
The `PulseCount` class implements a bi-directional counter typically used with a rotary encoder.

```js
import PulseCount from "tc53:io/pulsecount";
```

#### Properties of constructor options object
| Property | Description |
| :---: | :--- |
| `signal` | Pin specifier for the signal input pin. This property is required.
| `control` | Pin specifier for the control input pin. This property is required.

#### Data format
The `PulseCount ` class data format is always a number. The values are always integers.

#### Methods

**`read()`**

The `read` method returns the current count. It takes no arguments.

The count is initialized to zero at the time of instantiation. Note that the initial call to `read` may return a non-zero value if pulses have been counted in the intervening interval.

**`write(count)`**

The `write` method sets the current count.

#### Callbacks

**`onReadable()`**

The `onReadable` callback is invoked when the value of the counter has changed. Multiple changes to the counter may be combined into a single invocation of the callback.

**`onError()`**
The `onError ` callback is invoked when an error is detected, for example, underflow or overflow of the counter.


### TCP cocket
The `TCP` network socket class implements a general purpose, bi-directional TCP connection. 

```js
import TCP from "tc53:io/socket/tcp";
```

The TCP socket is not a TCP listener, as in some networking libraries. The TCP listener is a separate class.

#### Properties of constructor options object
| Property | Description |
| :---: | :--- |
| `address` | A string with the IP address of the remote endpoint to connect to. Either the `address` or `host` property must be provided.
| `host` | A string with the DNS name of the remote endpoint to connect to. Either the `address` or `host` property must be provided.
| `port` | A number specifying the remote port to connect to. This property is required.
| `noDelay` | A boolean indicating whether to disable Nagle's algorithm on the socket. This property is equivalent to the `TCP_NODELAY` option in the BSD sockets API. This property is optional and defaults to false.
| `keepAlive` | A number specifying the keep-alive interval of the socket in milliseconds. This property is optional and if not present, the keep-alive capability of the socket is not used.
| `from` | An existing TCP socket instance from which the native socket instance is taken to use with the newly created socket instance. This property is optional and intended for use with a TCP listener. When the `from` property is present, the `address`, `host`, and `port` properties are not required and are ignored if specified. The original instance is closed with ownership of the native socket transferred to the new instance.

#### Callbacks

**`onReadable(bytes)`**

Invoked when new data is available to be read. The callback receives a single argument that indicates the number of bytes available to read.

**`onWritable(bytes)`**

Invoked when space has been made available to output additional data. The callback receives a single argument that indicates the total number of bytes that may be written to the TCP socket without overflowing the output buffers.

The `onWritable` callback is invoked when the socket successfully connects to the remote host and it is possible to write data.

**`onError()`**

The `onError` callback is invoked when an error occurs or the TCP socket disconnects. Once `onError` is invoked, the connection is no longer usable. Reporting the error type is an area for future work.

#### Data format
The `TCP` class data format is either `number` for individual bytes or `buffer` for groups of bytes. The default data format is `buffer`. When using the `buffer` format, the `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.

### TCP listener socket
The TCP `Listener` class listens for and accepts incoming TCP connection requests.

```js
import Listener from "tc53:io/socket/listener";
```

#### Properties of constructor options object
| Property | Description |
| :---: | :--- |
| `port` | A number specifying the port to listen on. This property is optional.
| `address` | A string with the IP address of the network interface to bind to. This property is optional.

#### Methods

**`read()`**
The `read` function returns a `TCP` Socket instance. The instance is already connected to the remote host. There are no callback functions installed.

> **Note:** To set the callbacks and configure the socket, pass the socket to the `TCP` Socket constructor using the `from` property.

**`write()`**

Unsupported.

#### Callbacks

**`onReadable(requests)`**

Invoked when one or more new connection requests are received. The callback receives a single argument that indicates the total number of pending connection requests.

#### Data format
The TCP `Listener` class uses `socket/tcp` as its sole data format.

### UDP socket
The `UDP` network socket class implements the sending and receiving of UDP packets. 

```js
import UDP from "tc53:io/socket/udp";
```

#### Properties of constructor options object
| Property | Description |
| :---: | :--- |
| `port` | The local port number to bind the UDP socket to. This property is optional.
| `address` | A string with the IP address of the network interface to bind to. This property is optional.
| `multicast` | A string with the IP address of a multicast address to bind to. This property is optional.
| `timeToLive` | A number with the multicast time-to-live value as a number from 1 to 255. This property is required if the `multicast` property is provided and otherwise ignored.

#### Methods

**`read()`**
The `read` call returns a complete UDP packet as an `ArrayBuffer`. The returned packet data has the following properties attached to it: 

- `address`, a string containing the packet sender's IP address
- `port`, the port number used to send the packet.

**`write(address, port, packet)`**
The `write` call takes three arguments: remote address string, remote port number, and the packet data as an `ArrayBuffer` or `TypedArray`. If there is insufficient memory to transmit the packet, the `write` call throws an exception.

#### Callbacks

**`onReadable(packets)`**

Invoked when one or more packets are received. The callback receives a single argument that indicates the total number of packets available to read.

#### Data format
The `UDP` class data format is always `buffer`. The `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.

## 11 IO Providers Class Pattern

The IO Providers Class Pattern builds on the Base Class Pattern to provide a foundation to access a collection of IO Classes.

An IO Provider contains one or more IO Classes. The IO Provider may be connected to the host in any way, including:

- A direct hardware connection such as I²C or SPI
- A local wireless connection such as BLE using the Automation IO Service profile
- A TCP/IP connection to an internet cloud service

It is anticipated, but not required, that implementations of the IO Provider Class Pattern will perform IO using instances conforming to the IO Class Pattern. To facilitate that, the constructor uses IO constructor properties to specify their IO connections.

An IO Provider instance contains IO Classes which conform to the IO Class Pattern. The following code is an example of using an IO Provider to access a Digital pin on a GPIO expander connected via I²C.

```js
import I2C from "tc53:io/i2c";

const expander = new Expander({
	io: I2C,
	data: 5,
	clock: 4,
	hz: 1_000_000,
	address: 0x20,
});

const led = new expander.Digital({
	pin: 13,
	mode: expander.Digital.Output,
});
led.write(1);
```
Here the `data` and `clock` pins passed to the `Expander` constructor refer to pins of the host whereas the `pin` passed to the `expander.Digital` constructor refers to a pin of the GPIO expander.

### `constructor`

Following the Base Class Pattern, the constructor has a single options object argument. The options object defines the hardware connections of the sensor. These use the same properties as the IO types corresponding to the hardware connection. As in the Peripheral Class Pattern, the IO properties in the Provider Class Pattern are grouped to avoid collisions.

The options object is not limited to IO connection information and must contain all information needed by the implementation to establish the connection.

### `close` method
In addition to releasing all resources as required by the Base Class Pattern, the `close` method causes the `onError` callback to be invoked on all open instances. Note that `onError` may not be invoked from within `close` (see Callbacks section).

### Callbacks

**`onReady()`**

The `onReady` callback is invoked once the IO Provider instance is ready for use.

The IO provider may not know what IO resources are available until it has successfully established a connection to the remote resource. For this reason, a provider may not have any IO constructors on its instance until the `onReady` is invoked.

The IO constructors of an IO Provider, if present on the instance, may be used prior to `onReady` being invoked.

**`onError()`**

The `onError` callback is invoked on a non-recoverable error to indicate that the provider instance can no longer be used.

When a provider fails, its IO instances also become unusable, and consequently `onError` must also be invoked on each instance.

## 12 Peripheral Class Pattern

The Peripheral Class Pattern builds on the Base Class Pattern to provide a foundation for implementing access to different kinds of peripheral devices. The Peripheral Class Pattern is purely abstract and cannot be instantiated directly.

### `constructor`

Following the Base Class Pattern, the constructor has a single options object argument. The options object defines the hardware connections of the peripheral. These use the same properties as the IO types corresponding to the hardware connection. For example, an I²C peripheral:

	import I2CPeripheral from "tc53:example/i2cperipheral";
	import I2C from "tc53:io/i2c";

	let t = new I2CPeripheral({
		io: I2C,
		data: 4,
		clock: 5,
		address: 0x30
	});


The `io` property specifies the constructor for the IO Class.

If the peripheral has multiple hardware connections, the options object separates them to avoid collisions. For example, here the peripheral has an I²C connection for primary communication and a digital connection for an interrupt:

	import I2CPeripheralWithInterrupt from "tc53:example/i2cperipheralwithinterrupt";
	import I2C from "tc53:io/i2c";
	import Digital from "tc53:io/digital";

	let t = new I2CPeripheralWithInterrupt({
		communication: {
			io: I2C,
			data: 4,
			clock: 5,
			address: 0x30
		},
		interrupt: {
			io: Digital,
			pin: 5
		}
	});

The constructor must reset the peripheral hardware to a consistent initial state so the peripheral's behavior is not dependent on a previous instantiation. This reset may include calling the instance's `configure` method.

### `close` method

The `close` method, as required by the Base Class Pattern, releases all IO connections in use by the instance.

### `configure` method

The `configure` method modifies how the peripheral operates. It has a single argument, an options object.

The `configure` method follows the same rules regarding the options argument as the `constructor` and therefore may not modify its content.

Because peripherals have many features, the `configure` method may implement support for many properties. A given call to the `configure` method should only modify the features specified in the options object. 

The Peripheral Class Pattern does not require a script call the `configure` method to use the peripheral, however specific implementations may require `configure` to be called.

The `configure` method may be called more than once to allow scripts to reconfigure the peripheral.

### Accessors for configuration

Classes that follow the Peripheral Class Pattern may choose to provide accessors, e.g. setters and getters, for configuration properties. A setter should behave in the same way as the `configure`  method invoked with a single property. For example, a setter for a property named `resolution` could be  implemented as follows:

```js
class ExamplePeripheral {
	...
	set resolution(value) {
		this.configure({resolution: value});
	}
}
```
A getter for the same property could be implemented as follows:

```js
class ExamplePeripheral {
	...
	get resolution() {
		this.configuration.resolution;
	}
}
```

<!-- Note: this assumes the configuration property is implemented from the sensor provenance section -->



## 13 Sensor Class Pattern

The Sensor Class Pattern builds on the Peripheral Class Pattern to provide a foundation for implementing access to a variety of sensors.

It is anticipated, but not required, that instances conforming to the Sensor Class Pattern will perform IO using instances conforming to the IO Class Pattern. The Sensor Class Pattern is therefore non-blocking, like IO. Additionally, the constructor uses IO constructor properties to specify their IO connections.

The Sensor Class Pattern provides low-level sensor access, similar to a sensor driver provided by a sensor manufacturer, to support access to all the unique capabilities of the sensor. As with IO, where a given type of device (e.g. a temperature sensor) has common capabilities across manufacturers, the individual sensor types define a common way to access that functionality.

Higher-level sensor APIs may be built using instances of the Sensor Class Pattern. The W3C Generic Sensor specification, for example, may be implemented using sensors conforming to The Sensor Class Pattern.

The Sensor Class Pattern may be used together with the Sensor Data Provenance Rules to improve the usability of the data collected.

### `constructor`

Following the Peripheral Class Pattern, the constructor has a single options object argument. The options object defines the hardware connections of the sensor. 

For example, here the temperature sensor has an interrupt on a Digital pin:

	import I2C from "tc53:io/i2c";
	import Digital from "tc53:io/digital";

	let t = new Temperature({
		sensor: {
			io: I2C,
			data: 4,
			clock: 5,
			address: 0x30
		},
		interrupt: {
			io: Digital,
			pin: 5
		}
	});

The constructor must reset the sensor hardware to a consistent initial state so the sensor's behavior is not dependent on a previous instantiation.

### `configure` method

The `configure` method is inherited from the Peripheral Class Pattern. For sensors, it modifies how the sensor operates. This may include the hardware's sampling interval, what data is sampled, and the range of the data sampled. 

### `sample` method

The `sample` method returns readings from the sensor. The Sensor Class Pattern defines no arguments for the `sample` method, though individual sensor types may.

The `sample` method returns an object containing one or more properties. The returned object is mutable. The implementation must return a different object on each invocation to allow calls to accumulate multiple sensor readings.

> **Note:** A sensor implementation of `sample` may accept an input argument of the object to use for the sensor data as an optimization to reduce memory manager work. If supported, this must be specified for the Sensor Class' `sample` method.

If the sample data includes timestamps (e.g. when the sample was collected), those timestamps in the returned sample object should conform to the Sensor Data Provenance Rules.

### Callbacks

The Sensor Class Pattern specifies one callback that is set by the options object passed to the constructor. Individual sensor classes may provide additional callbacks, for instance, to indicate when a sample is available or a sensed condition has been met.

**`onError()`**

The `onError` callback is invoked on a non-recoverable error to indicate that the sensor instance can no longer be used. The only method that should be called is `close`.

## 14 Sensor classes

This section defines Sensor Classes conforming to the Sensor Class Pattern.

The classes support common sensor capabilities. Capabilities that are not supported here may be added using the extensibility options of the Sensor Class Pattern and Base Class Pattern.

### Accelerometer

The `Accelerometer` class implements access to a three-dimensional accelerometer. 

#### Properties of a sample object
These properties are compatible with the attributes of the same name in the [W3C Accelerometer draft](https://w3c.github.io/accelerometer/).

| Property | Description |
| :---: | :--- |
| `x` | A number that represents the sampled acceleration along the x axis in meters per second squared. This property is required.
| `y` | A number that represents the sampled acceleration along the y axis in meters per second squared. This property is required.
| `z` | A number that represents the sampled acceleration along the z axis in meters per second squared. This property is required.

### Ambient light

The `AmbientLight` class implements access to an ambient light sensor. 

#### Properties of sample object
These properties are compatible with the attributes of the same name in the  [W3C Ambient Light Sensor draft](https://www.w3.org/TR/ambient-light/).

| Property | Description |
| :---: | :--- |
| `illuminance` | A number that represents the sampled ambient light level in Lux. This property is required.

### Atmospheric pressure

The `AtmosphericPressure` class implements access to an atmospheric pressure sensor or barometer.

#### Properties of a sample object

| Property | Description |
| :---: | :--- |
| `pressure` | A number that represents the sampled atmospheric pressure in Pascal. This property is required.

### Humidity

The `Humidity` class implements access to a humidity sensor.

#### Properties of a sample object

| Property | Description |
| :---: | :--- |
| `humidity` | A number that represents the sampled relative humidity as a percentage. This property is required.

### Proximity

The `Proximity` class implements access to a proximity sensor or range finder.

#### Properties of a sample object
These properties are compatible with the attributes of the same name in the  [W3C Proximity Sensor draft](https://w3c.github.io/proximity/).

| Property | Description |
| :---: | :--- |
| `near` | A boolean that indicates if a proximate object is detected. This property is required.
| `distance` | A number that represents the distance to the nearest sensed object in centimeters or `null` if no object is detected. This property is optional: some proximity sensors can only provide the `near` property. 
| `max` | A number that represents the maximum sensing range of the sensor in centimeters.

### Temperature

The `Temperature` class implements access to a temperature sensor.

#### Properties of a sample object

| Property | Description |
| :---: | :--- |
| `temperature` | A number that represents the sampled temperature in degrees Celsius. This property is required.

### Touch

The `Touch` class implements access to a touch panel controller.

#### Sample object

The `Touch` class `sample` method returns an array of `touch` objects, as specified below. If there is no touch in progress, `sample` returns `undefined`.

##### Properties of `touch` object
 
| Property | Description |
| :---: | :--- |
| `x` | Number indicating the X coordinate of the touch point
| `y` | Number indicating the Y coordinate of the touch point
| `id` | Number indicating which touch point this entry corresponds to

## 15 Display Class Pattern

The Display Class Pattern builds on the Peripheral Class Pattern to provide a foundation for implementing access to displays represented by a two-dimensional array of pixels.

The Display Class Pattern is designed to support displays independent of hardware architecture. For example, it may be used efficiently with both frame buffers stored in local host memory and frame buffers connected with the [MIPI Display Serial Interface](https://mipi.org/specifications/dsi).

### constructor

Following the Peripheral Class Pattern, the constructor has a single options object argument. The options object defines the hardware connections of the display. These use the same properties as the IO types corresponding to the hardware connection.

A Display Class is not required to have properties to configure its hardware connections. For example, a memory mapped display may have no external connections. Or, a Display Class may be preconfigured for the hardware of a specific host.

### `configure` method

The following table enumerates the properties defined for the options object argument:

| Property | Description |
| :---: | :--- |
| `format` | A number indicating the format of pixel data passed to the instance (for example, to the `send` method). This property is optional. If the format provided is not supported by the Display Class, a `RangeError` is thrown.
| `rotation` | The clockwise rotation of the display as a number. This property is optional. If the value provided is not 0, 90, 180, or 270, or is unsupported by the Display Class, a `RangeError` is thrown.
| `brightness` | The relative brightness of the display from 0 (off) to 1.0 (full brightness). This property is optional. 
| `flip` | A string indicating whether the pixels should be flipped horizontally and/or vertically. Allowed values are `""`, `"h"`, `"v"`, and `"hv"`. The empty string indicates that neither horizontal nor vertical flip is applied. This property is optional.

<!--
| `colorTable` | A `Uint8Array` containing a packed array of RGB color values (8-bits per channel) to define the color table for indexed displays. This property is optional. 
-->

Note that no default values are defined by the Display Class Pattern for these configuration properties to allow the host to provide default values that are appropriate for its hardware.

> **Proposed:** Because the defaults may be configured by the host, it is sometimes useful to retrieve the current configuration. One solution is to return the current configuration from the `configure` call, perhaps as an option signaled by a property (e.g. `{get: true}`). This approach is convenient for scripts that need to check if particular configuration options are applied. Another approach is to have a separate method (e.g. `getConfiguration()`) to return the current configuration.

### `begin` method

The `begin` method starts the process of updating the display's pixels. If no arguments are passed, the entire frame buffer is updated starting at the top-left corner (coordinate `{0, 0}`), proceeding left-to-right, top-to-bottom, ending at the bottom-right corner (coordinate `{width, height}`).

If an options object is passed as the sole argument, the object may contain `x`, `y`, `width`, and `height` properties that define a rectangular area to update. The rectangle must fit within the bounds of the display (e.g. `{0, 0, width, height}`) or a `RangeError` is thrown.

A display may not support all possible update areas. For example, a display may only support updates aligned to even horizontal pixels. A `RangeError` is thrown if an unsupported update area is passed to `begin`. Prior to calling begin, the `adaptInvalid` method may be used to adjust the update area to the capabilities of the display. 

The options object has an optional `continue` property to support discontiguous updates on displays that use page flipping to swap between multiple frame buffers. When `continue` is `false`, the default value, the call to the `begin` method starts to update a new frame. Calling `begin` with `continue` set to `true` continues updating the same frame rather than starting a new one.

An `Error` exception is thrown if the `begin` method is called more than once without an intervening call to the `end` method, unless `continue` is set to true in the successive calls. For example, this is a valid call sequence to update three horizontal slices of the display.

```javascript
display.begin({x: 0, y: 0, width: 240, height: 10});
display.send(pixels);
display.begin({x: 0, y: 20, width: 240, height: 10, continue: true});
display.send(pixels);
display.begin({x: 0, y: 40, width: 240, height: 10, continue: true});
display.send(pixels);
display.end();
```

### `send` method

The `send` method delivers one or more horizontal scan lines of pixel data to the display. The sole argument to `send` is a buffer of pixels stored either in an `ArrayBuffer` or an ArrayBuffer view. The pixels are stored in a packed array with no padding between scan lines. The format of the pixels matches the `format` property of the options object of the `configure` method.

### `end` method

The `end` method finishes the process of updating the display's pixels, by making all pixels visible on the display. If the display instance buffers pixels, all pixels musts be flushed. If the display uses page flipping, the page must be flipped to the most recently updated buffer.

### `adaptInvalid` method

The `adaptInvalid` method accepts a single options object argument that includes `x`, `y`, `width`, and `height` properties that describe an area of the display to be updated. It adjusts these properties as necessary so that the result is valid for the display and encloses the original update area.

Consider a display which limits the update area horizontally to even pixel positions. The following code calls a display's `adaptInvalid` method with odd numbers for both left and right edges of the update area:

```javascript
const area = {x: 3, y: 20, width: 10, height: 20};
display.adaptInvalid(area);
display.begin(area);
display.send(pixels);
display.end();
```

An implementation of `adaptInvalid` to apply the rules above, if implemented in JavaScript, would be:

```javascript
function adaptInvalid(options) {
	if (options.x & 1) {
		options.x -= 1;
		options.width += 1;
	}
	if (options.width & 1) {
		options.width += 1;
	}
}
```

Some displays require that the update area only include full scan lines. The following function shows the implementation for such a display, assuming a scanline width of 128 pixels;

```javascript
function adaptInvalid(options) {
	options.x = 0;
	options.width = 128;
}
```

For displays that only support full screen updates, `adaptInvalid` updates the rectangle to be the full display dimensions. The following function shows the implementation for a QVGA (320 x 240) display:

```javascript
function adaptInvalid(options) {
	options.x = 0;
	options.y = 0;
	options.width = 320;
	options.height = 240;
}
```

### Instance properties

**`width`** The width of the display in pixels as a number. This property is read-only. This value may change based on the configuration, for example, when changing orientation from portrait to landscape. 

**`height`** The height of the display in pixels as a number. This property is read-only. This value may change based on the configuration, for example, when changing orientation from portrait to landscape. 

### Pixel `format` values

| Property | Description |
| :---: | :--- |
| 3 | 1-bit monochrome |
| 4 | 4-bit grayscale (0 black, 15 white) |
| 5 | 8-bit grayscale (0 black, 255 white) |
| 6 | 8-bit RGB 3:3:2 |
| 7 | 16-bit RGB 5:6:5 little-endian |
| 8 | 16-bit RGB 5:6:5 big-endian |
| 9 | 24-bit RGB 8:8:8 |
| 10 | 32-bit RGBA 8:8:8:8 |
| 12 | 12-bit xRGB 4:4:4:4 (x is unused) |

<!-- 11 reserved for 4-bit Color Look-up Table -->

## 16 Host provider instance

The Host Provider instance aggregates data and code available to scripts from the host. The host provider instance is available as a module import:

```js
import hostProvider from "tc53:provider/builtin";
```

The Host Provider instance is instantiated before hosted scripts are executed. Only a single instance of the host provider may be created, and the host provider cannot be closed or garbage collected.

The following sections define properties of the Host Provider instance. The Host Provider instance has no required properties.

### Pin name property

The `pins` property is an object that maps pin names to pin specifiers. More than one pin name may map to the same pin specifier.

```js
import Digital from "tc53:io/digital";

let led = new Digital({
	pin: hostProvider.pins.led,
	mode: Digital.Output
})
```

### IO bus properties

An IO Bus is two or more pins used to implement a communication protocol such as Serial, SPI, or I²C. There may be one or more instances of an IO Bus and one may be designated as the default bus of that type.

The Host Provider instance may contain properties corresponding to each bus type. The following bus types are defined for those host provider instance.

| Bus Type | Property Name |
| :---: | :--- |
| I²C | `i2c` |
| Serial | `serial` |
| SPI | `spi` |

Each bus type may contain one or more buses. Each bus may have one or more names. It is recommended to provide a property named `default` when there is a default bus.

```js
// example host implementation
const A = {
	in: 12,
	out: 13,
	clock: 14,
	select: 15,
	hz: 10_000_000
};

const B =  {
	in: 0,
	out: 1,
	clock: 2,
	select: 3,
	hz: 20_000_000
};

hostProvider.spi = {
	A,
	B,
	default: B
}
```

```js
// example hosted script use

import SPI from "tc53:io/spi";

let spi = new SPI(hostProvider.spi.default);
```

### IO classes

The host provider instance may provide access to its IO constructors through its `io` property. This is analogous to the IO constructors available from an IO Provider.

```js
// example host provider implementation

import Digital from "tc53:io/digital";
import I2C from "tc53:io/i2c";
import SPI from "tc53:io/spi";

...
hostProvider.io = {
	Digital,
	I2C,
	SPI
};
```

```js
// example hosted script use

import hostProvider from "tc53:provider/builtin";

let spi = new hostProvider.io.SPI(hostProvider.spi.default);
```

### IO providers
The host provider instance may provide access to IO Providers constructors through its `providers` property.

### sensors
The host provider instance may provide access to Sensor constructors through its `sensor` property.

### displays
The host provider instance may provide access to Display constructors through its `sensor` property.

## 17 Provenance rules for sensor data

To do.


## Bibliography

- [I²C-bus specification and user manual, Rev. 6](https://www.nxp.com/docs/en/user-guide/UM10204.pdf)
- [System Management Bus (SMBus) Specification
Version 3.1](http://smbus.org/specs/SMBus_3_1_20180319.pdf)
- [W3C Generic Sensor specification](https://www.w3.org/TR/generic-sensor/)
- [W3C Accelerometer draft](https://w3c.github.io/accelerometer/)
- [W3C Ambient Light Sensor draft](https://www.w3.org/TR/ambient-light/)
- [W3C Proximity Sensor draft](https://w3c.github.io/proximity/)

References needed for:

- SPI
- Serial/UART

>**Note**: These are more industry consensus than industry standard. It may be challenging to find a definitive reference. How to handle? Where to look for guidance?



## Copyright & software license

Ecma International<br/>
Rue du Rhone 114<br/>
CH-1204 Geneva<br/>
Tel: +41 22 849 6000<br/>
Fax: +41 22 849 6001<br/>
Web: [https://ecma-international.org/](https://ecma-international.org/)


### Copyright notice

© 2020 Ecma International

This document may be copied, published and distributed to others, and certain derivative works of it may be prepared, copied, published, and distributed, in whole or in part, provided that the above copyright notice and this Copyright License and Disclaimer are included on all such copies and derivative works. The only derivative works that are permissible under this Copyright License and Disclaimer are: 

1.  works which incorporate all or portion of this document for the purpose of providing commentary or explanation (such as an annotated version of the document),
1. works which incorporate all or portion of this document for the purpose of incorporating features that provide accessibility,
1. translations of this document into languages other than English and into different formats and
1. works by making use of this specification in standard conformant products by implementing (e.g. by copy and paste wholly or partly) the functionality therein.

However, the content of this document itself may not be modified in any way, including by removing the copyright notice or references to Ecma International, except as required to translate it into languages other than English or into a different format.

The official version of an Ecma International document is the English language version on the Ecma International website. In the event of discrepancies between a translated version and the official version, the official version shall govern.

The limited permissions granted above are perpetual and will not be revoked by Ecma International or its successors or assigns.

This document and the information contained herein is provided on an "AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE."

### Software license

All Software contained in this document ("Software") is protected by copyright and is being made available under the "BSD License", included below. This Software may be subject to third party rights (rights from parties other than Ecma International), including patent rights, and no licenses under such third party rights are granted under this license even if the third party concerned is a member of Ecma International. SEE THE ECMA CODE OF CONDUCT IN PATENT MATTERS AVAILABLE AT [https://ecma-international.org/memento/codeofconduct.htm](https://ecma-international.org/memento/codeofconduct.htm) FOR INFORMATION REGARDING THE LICENSING OF PATENT CLAIMS THAT ARE REQUIRED TO IMPLEMENT ECMA INTERNATIONAL STANDARDS.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. Neither the name of the authors nor Ecma International may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE ECMA INTERNATIONAL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ECMA INTERNATIONAL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
