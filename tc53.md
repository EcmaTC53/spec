<p id="subtitle">TC53 Draft / June22, 2020</p>
<p id="title">ECMAScript® Modules for Embedded Systems</title>

<img src="./assets/ecma-logo.svg">

<a id="introduction"></a>
## Introduction

The TC53 specification defines APIs intended for use on embedded systems. Embedded systems are far more diverse than personal computers, smart phones, and web servers where ECMAScript is most widely used. The diversity of embedded hardware is a consequence of devices being optimized for a specific product or class of products. It is not enough for the TC53 APIs to support the features the embedded systems have in common. To be truly useful, they must allow the unique features of the hardware to be supported. This requirement makes this specification very different from the specification of a computer language which is grounded in the formality and rigor of mathematics. Hardware can be inconsistent, even sometimes messy, but it needs to be accommodated. 

The ability for scripts to access unique hardware features has an important consequence. It means that not all correct scripts will run correctly on all hardware. If a script requires a feature that is unavailable, it cannot run. While it is common in ECMAScript to use a "polyfill" to emulate missing language and runtime features, this is usually impractical, if not impossible, for hardware features. Thus, the goal of this specification is to make it possible to write portable scripts for specified operations, but not to guarantee that all scripts execute correctly on any conformant deployment.

One important consideration when designing hardware products is cost. The APIs are designed to allow efficient execution with minimal resource use. They assume no minimum or maximum configuration. Advances in the state-of-the art of ECMAScript engines, microcontrollers, and runtime libraries will determine where these APIs may be used.

This specification is influenced by the Extensible Web Manifesto. It aims to provide low level APIs that do things -- primarily related to hardware and communication -- that the ECMAScript language cannot do by itself. These low-level APIs are functional, simple, and efficient. The APIs may be used directly. However, it is expected that many developers will interact with them indirectly through higher level modules and frameworks that build upon the low-level APIs. This layered approach keeps the low-level APIs small and focused while allowing a variety of uses and API styles to be build on them.

### ECMAScript

This specification builds on Standard ECMAScript as defined by Ecma TC39. As of this writing, that is ECMAScript 2020.

This specification is not an extension or subset of ECMAScript 2020. It is a set of APIs to be used within that specification. The relationship between TC53 and ECMAScript is analogous to the relationship between ECMAScript Internationalization API (ECMA 402) and ECMAScript.

### Class Patterns

A Class Pattern, as used in this specification, is combination of requirements and guidelines for a class. For example, the IO Class Pattern defines behaviors for all IO classes.

TC53 defines classes in terms of Class Patterns. In the future, there may be truly formal classes such as those found in the ECMAScript Language.

Requirements are behaviors defined by TC53 and must be adhered to for a conformant implementation. A Class Pattern can be seen as similar to a collection of Abstract Operations in the ECMA-262.

Guidelines are primarily for extensibility. Extensibility is essential to TC53 as unique hardware capabilities must be possible to access. Extensibility is problematic because of the potential for collisions. This specification provides requirements for how extensibility may be implemented.

Unless stated, there are no rules about class inheritance. An implementation of a class pattern may inherit from `Object` or any other class, so long as it conforms.

### Independent Implementations

This specification is intended to facilitate multiple independent implementations of the APIs. A single API may warrant an entirely different implementation depending a variety of factors that include the hardware, operating system, and ECMAScript engine.

### Self-Hosting

The ECMAScript language is defined in terms of a host that provides the runtime environment for execution of scripts. This specification does not change that. The APIs defined herein are provided by a host. However, this specification does anticipate that portions of the runtime environment provided by the host may themselves be implemented in ECMAScript. This specification refers to a host that includes some ECMAScript code in its implementation as self-hosting.

One challenge of self-hosting is keeping the host fully separated from the scripts, to avoid security, robustness, and compatibility problems. The Compartment model defined as part of the Secure ECMAScript proposal provides a solution for separating hots scripts and hosted scripts.

Note: Self-hosting is not required.

<!--
### Immutability

Immutability of object properties is a feature of ECMAScript. It is not widely used, however. Immutability is valuable for embedded systems and consequently this specification makes use of it in several ways.

- Data may be stored in read-only memory, reducing the RAM required for execution
- Improving secure as they are inherently resistant to tampering
- Simplifying implementation, as in...

-->

### Module Specifiers

This specification specifies classes which are accessed through modules. Because many embedded systems lack a file system, using file paths to access modules is impractical and contrived. Instead, modules are accessed using bare module specifiers. While such specifiers are forbidden in a web browser, they are permitted in other environments.

To avoid naming collisions with bare module specifiers, a namespace prefix has been [proposed](https://github.com/tc39/proposal-built-in-modules#namespace). This specification will use a single namespace prefix (currently "tc53:" but expected to change). For example,

	import Digital from "tc53:builtin/digital";

For avoidance of doubt, the use of bare module specifiers by this specification does not prevent an engine from also providing support for other kinds of module specifiers.

### Secure ECMAScript

Secure ECMAScript (SES) is a proposal to extend the language to support provably secure execution of scripts in an environment that combines trusted and untrusted scripts. The two foundations of Secure ECMAScript are immutability and compartments. SES makes all primordials immutable prior to execution of any script code. This ensures all built-in object behave as defined by the language, disables common attack vectors, and eliminates communication side-channels. Compartments allow one script to sandbox another scripts, limiting the globals and modules that are available in the sandbox.

The security guarantees provided by SES are necessary to building large systems that contains code from many sources, not all of which may be fully trusted. The mechanisms proposed by SES allow for an efficient implementation. Further, the immutability requirement for SES allows the primordials to be stored in read-only memory, reducing RAN use and allowing them to be securely shared by multiple virtual machines.

This specification is designed to be used with SES when a runtime security solution is required. If and when the SES proposal is an approved standard, this specification will reference it normatively.

SES consists of two major execution phases - pre-lockdown and post-lockdown. Prior to lockdown primordials are mutable and Compartments are unavailable. A TC53 host is not required to support pre-lockdown on the target hardware. A host may complete lockdown as part of the build process, for example.

<a id="scope"></a>
## 1 Scope

This Standard defines the application programming interface for ECMAScript modules that support programs executing on embedded systems. 

<a id="conformance"></a>
## 2 Conformance


<a id="normative-references"></a>
## 3 Normative References

The following referenced documents are required for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.

ECMAScript Language Specification (ECMA-262 10<sup>th</sup> Edition, or successor).<br>
    <a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a>

> NOTE: Throughout this document, the phrase &ldquo;ES2020, _x_&rdquo; (where x is a sequence of numbers separated by periods) may be used as shorthand for "ECMAScript Language Specification (ECMA-262 10<sup>th</sup> Edition, sub clause _x_)".

  
<a id="notational-conventions"></a>
## 4 Notational Conventions
    
<a id="requirements"></a>
## 5 Requirements for Standard Built-in ECMAScript Objects

Unless specified otherwise in this document, the objects, functions, and constructors described in this standard are subject to the generic requirements and restrictions specified for standard built-in ECMAScript objects in the ECMAScript Language Specification, 10th edition, clause [17](https://tc39.es/ecma262/#sec-ecmascript-standard-built-in-objects), or successor. 

<a id="base-class-pattern"></a>
## 6 Base Class Pattern

The Base Class Pattern defines common behaviors used for use by other class patterns. The  Base Class Pattern is purely abstract and cannot be instantiated directly.

Classes conforming to the Base Class Pattern may be subclassed.

### `constructor`

The constructor of the Base Class Pattern takes an options object (sometimes called a dictionary) as its first argument.

Only the `target` properties is defined in options object by the Based Class Pattern. 

Typically there are no other arguments as additional configuration options can and should be added to the options object. However, additional arguments are not prohibited.

It is an error to invoke the constructor without the options object. An exception will be thrown.

The implementation of the constructor should validate all supported option properties before allocating any resources. This behavior avoids enabling or changing the state of any hardware should the constructor fail due to invalid parameters.

The implementation must ignore any unrecognized option properties.

If the constructor fails to complete execution successfully, it must release any resources already allocated prior to exiting.

The constructor must not modify the options object. It must allow for passing an immutable options object.

Once the instance has been successfully constructed, it must not be eligible for garbage collection until explicitly released by calling `close`. This is done so scripts do not need to maintain a reference to the object to prevent it from being collected, similar to `setInterval`/`clearInterval` and the W3C Generic Sensor.

### `close` method

The `close` method releases all resources associated with the instance.

Once `close` completes, the object is eligible for garbage collection.

Once `close` completes, an `Error` exception is thrown if any instance methods are called. (Note: should a better error be defined for this?)

### `target` property

The `target` property is opaque to the object's implementation. It may be initialized by the constructor using the `target` property in the options object. Scripts may both read and write the target property, though it is typically only set at construction.

### Callbacks

Instances of the Base Class Pattern typically use function callbacks to deliver asynchronous events. 

Callback functions are provided to the instance as properties in the options object. 

	new Button({
		onPush() {
		},
		onRelease() {
		}
	});

Callback functions are invoked with `this` set to the instance. This can be overridden using standard ECMAScript features, such as arrow functions:

	new Button({
		onPush: () => {
		},
		onRelease: () => {
		}
	});

The callbacks are stored internally by the implementation. They are not public methods. The callback functions cannot be read and are only set using the constructor's options object. 

A callback function may only be invoked when no script is running in its host virtual machine to respect the [single-thread evaluation semantics of ECMAScript](https://tc39.es/ecma262/#sec-happens-before). This mean that callbacks may not be invoked by the instance from within its public method calls, including the constructor.

Callbacks must be invoked in the same virtual machine in which they were created. 

### Naming

The Base Class Pattern uses the camel-case naming convention for property names.

It follows the usual ECMAScript convention of naming classes with an initial capital letter and methods with an initial lower case letter.

Callback function names begin with `on`.

<a id="io-class-pattern"></a>
## 7 IO Class Pattern

The IO Class Pattern builds on the Base Class Pattern to provide a foundation for implementing access to a variety hardware inputs and outputs.

All IO is non-blocking, consistent with ECMAScript API behavior on the web platform. That said, not all operations are instantaneous. Implementations determine how long is too long for a given operation.

Non-blocking IO is facilitated by two callback functions, `onReadable` and `onWritable`, which eliminate the need for polling in most cases.

### constructor

The options object contains the specification of the hardware resources to be used by the instance. For example, a digital output has a `pin` property to indicate the physical pin to use.

The value of the `pin` property is implementation dependent. It is often a number corresponding to the logical GPIO pin number as per the hardware data sheet (e.g. GPIO 5), but it may be a string ("D1") or even an object ({port: 1, pin: 5}). Some IO classes use more than one pin, such as I²C which has clock and data pins. These may have the same kinds of values as a the `pin` property.

If thee constructor is called for a hardware resource that is already in use -- whether by a script or the native host -- an `Error` exception is thrown. (Note: better error?)

This specification allows, but does not require, an implementation to open multiple instances for the same hardware resource, if the instances cannot interfere with each other's operation. For example, this can work for a digital input  but would not for a digital output.

The IO Class Pattern is designed to be used both with IO types that have only a current value (e.g. Digital, analog, PWM) and IO types use streams of data (e.g. serial, SPI).

### `read` method

The `read` method returns data from the IO instance. If no data is available, it returns `undefined`.  The type of the data returned depends on the value of the `format` property.

The `read` method may take any number of arguments, including zero. The arguments are defined by the specific IO type.

If this instance does not support reading (because the IO type cannot be read or because it is configured for write-only) an Error exception is thrown.

### `write` method

The `write` method sends data to the IO instance.

If the device cannot accept the data because its buffers are full or the data is incompatible, an `Error` exception is thrown.

The `write` method may take any number of arguments, including zero. The arguments are defined by the specific IO type. The type of data accepted by `write` depends on the value of the `format` property.

If this instance does not support writing (because the IO type cannot be written or because it is configured for read-only) an Error exception is thrown.

### `format` property

The `format` property is a string that indicates the type of data used by the `read` and `write` methods. It is initialized by the constructor to the default defined for its IO type. The `format` property may be set by the script at any time to change how it reads and writes data.

The following values are defined by the IO Class Pattern for the `format` property. IO types may choose to support one or more, and may define others.

- `number` - an ECMAScript number value, typically used for bytes
- `buffer` - an `ArrayBuffer` instance
- `string;ascii` - an ECMAScript string from a 7-bit ASCII source
- `string;utf8` - an ECMAScript string from a UTF-8 source

The `format` property is implemented as a getter and setter. Attempting to set the `format` property to an unsupported value throws an `Error` exception and does not change the value.

### Callbacks

The IO Class Pattern specifies three callbacks which are set by the options object passed to the constructor. Most IO types operate with or without these callbacks installed, but a particular IO type may require one or more callbacks.

#### onReadable

The `onReadable` callback is invoked when the instance has data available to be read. Data is retrieved using the `read` method.

The `onReadable` callback may receive one or more arguments with information about the data available to read. The arguments are defined by the specific IO type.

The `onReadable` callback is invoked once when data arrives and not again until additional data is available to read.

#### onWritable

The `onWritable` callback is invoked when the instance is able to accept more data for output.

The `onWritable ` callback may receive one or more arguments with information about amount of data that may be written. The arguments are defined by the specific IO type.

#### onError

The `onError` callback is invoked when a non-recoverable error occurs. The instance is no longer usable. The only method that should be called is `close`.

Details of the error may be passed to the callback using arguments defined by the specific IO type.

<a id="io-classes"></a>
## 8 IO Classes

This section defines the IO Classes based on the IO Class Pattern.

The classes support capabilities commonly supported by hardware and runtimes. Capabilities that are not supported here may be added using the extensibility options of the IO Class Pattern and Base Class Pattern.

### Digital

The `Digital` IO class is used for digital inputs and outputs.

```js
import Digital from "tc53:io/digital";
```

#### Constructor Properties

| Property | Description |
| :---: | :--- |
| `pin` | A number from 0 to 16 indicating the pin number to control. This property is required. |
| `mode` |A value indicating the mode of the IO. May be `Digital.Input`, `Digital.InputPullUp`, `Digital.InputPullDown`, `Digital.InputPullUpDown`, `Digital.Output`, or `Digital.OutputOpenDrain`. This property is required. |
|`edge` | A value indicating the conditions for invoking the `onReadable` callback. Values are `Digital.Rising`, `Digital.Falling`, and `Digital.Rising | Digital.Falling`. This value is required if `onReadable` is present and ignored otherwise.

#### Callbacks

**`onReadable()`**

Invoked when the input value changes depending on the value of the `mode` property.

#### Data Format
The `Digital` class data format is always `number` with a value of either 0 or 1.

#### Notes
A digital IO instance configured as an input does not implement write; one configured as an output does not implement read.

### DigitalBank
The `DigitalBank` class provides simultaneous access to a group of digital inputs or outputs.

```js
import DigitalBank from "tc53:io/digitalbank";
```

#### Constructor Properties

| Property | Description |
| :---: | :--- |
| `pins` |A bit mask with pins to include in the bank set to 1. For example, the bit mask for a bank to access pins 2 and 3 is 0x0C (0b1100). This property is required.
| `mode` | A value indicating the mode of the IO, May be `Digital.Input`, `Digital.InputPullUp`, `Digital.InputPullDown`, `Digital.InputPullUpDown`, `Digital.Output`, or `Digital.OutputOpenDrain`. All pins in the bank use the same mode. This property is required.
| `rises` | A bit mask indicating the pins in the bank that should trigger an  `onReadable` callback when transitioning from 0 to 1. When an `onReadable` callback is provided, at least one pin must be set in `rises` and `falls`.
| `falls` | A bit mask indicating the pins in the bank that should trigger an  `onReadable` callback when transitioning from 1 to 0. When an `onReadable` callback is provided, at least one pin must be set in `rises` and `falls`.

#### Callbacks

**`onReadable(triggers)`**

Invoked when the input value changes depending on the value of the `mode`, `rises`, and `falls` properties. The `onReadable` callback receives a single argument, `triggers`, which is a bit mask indicating each pin that triggered the callback with a 1.

#### Data Format
Thee data format is always `number`. The value is a bit mask. On a read operation, any bit positions that are not included in the `pins` bit mask are set to 0.

> **Note**: This requirement prevents leaking the state of reserved pins and pins used by another bank.

#### Notes
A digital IO bank instance configured as an input does not implement write; one configured as an output does not implement read.

### Analog Input
The `Analog` IO class represents an analog input source.

```js
import Analog from "tc53:io/analog";
```

#### Constructor Properties

| Property | Description |
| :---: | :--- |
|  `pin` | The number of the analog input. This property is required.
|  `resolution` | The requested number of bits of resolution of the input. This property is optional.

#### Data Format
The data format is always a number. The value returned is an integer from 0 to a maximum value based on the resolution of the analog input.

#### `resolution` property
The read-only `resolution` property indicates the number of bits of resolution provided in values returned by the instance.

### PWM
The `PWM` IO class provides access to the pulse-width modulation capability of pins.

```js
import PWM from "tc53:io/pwm";
```

#### Constructor Properties

| Property | Description |
| :---: | :--- |
|  `pin` | A number from 0 to 16 indicating the GPIO number to operate as a PWM output. This property is required.
|  `hz` | A number specifying the requested frequency of the PWM output in Hz. This property is optional.

#### Data Format
The data format is always a number. The `write` call accepts integers between 0 and a maximum value based on the resolution of the PWM output.

#### `resolution` property
The read-only `resolution` property indicates the number of bits of resolution in values passed to the `write` method.

#### `hz` property
The read-only `hz` property returns the frequency of the PWM.

#### Notes
A PWM instance defaults to a duty cycle of 0% until `write` is called with a different value.

### I²C
<!-- alternative to master / slave? initiator/responder? primary/secondary? -->

The `I2C` class implements an I²C Master to communicate with one address on an I²C bus.

<!-- normative reference to  I²C? -->

```js
import I2C from "tc53:io/i2c";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `sda` | The I²C data pin. This property is required.
| `scl` | The I²C clock pin. This property is required.
| `hz` | The speed of communication on the I²C bus. This property is required.
| `address` | The 7-bit address of the target I²C device to communicate with. This property is required.

#### Data Format
The data format is always a buffer. The `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.

#### Specifying Stop Bit with `read` and `write` Methods
The I²C protocol is transaction-based. At the end of each read and write operation, a stop bit is sent. If the stop bit is 1, it indicates the end of the transaction; if 0, it indicates that the transaction has additional operations pending.

The `read` and `write` methods set the stop bit to 1 by default. An optional second argument to the `read` and `write` methods allows the stop bit to be specified. Pass `false` to set the stop bit to 0, and `true` to set the stop bit to 1. 

### SMBus
The `SMBus` class is extends the `I2C` class with additional methods to communicate with devices that implement the SMBus protocol.

<!-- normative reference to  SMBus? -->

```js
import SMBus from "tc53:io/smbus";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `stop` | A boolean value indicating whether to set the stop bit when writing the SMBus register number. This property is optional and defaults to `false`.

#### Methods
**`readUint8(register)`**

Reads and returns an unsigned 8-bit integer value from the specified register.

**`writeUint8(register, value)`**

Writes the unsigned 8-bit integer `value` to the specified register.

**`readUint16(register[, bigEndian])`**

Reads and returns an unsigned 16-bit integer value from the specified register. By default the value is read in little-endian byte order. If the optional `bigEndian` value is set to `true` the value is read in big-endian byte order.

**`writeUint16(register, value[, bigEndian])`**

Writes the unsigned 16-bit integer value to the specified register. By default the value is written in little-endian byte order. If the optional `bigEndian` value is set to `true` the value is written in big-endian byte order.

**`readBuffer(register, buffer)`**

Reads a stream of bytes starting at the specified `register` into the `ArrayBuffer` instance in the `buffer` argument . The number of bytes read is equal to the `byteLength` of the buffer.

**`writeBuffer(register, buffer)`**

Write a stream of bytes from the `ArrayBuffer` instance in the `buffer` argument starting at the specified `register`. The number of bytes read is equal to the `byteLength` of the buffer.

### Serial
The `Serial` class implements bi-directional serial (UART) communication.

```js
import Serial from "tc53:io/serial";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
|  `rx` | The receive pin. This property is required when using the serial connection to read data.
|  `tx` | The transmit pin. This property is required when using the serial connection to write data.
| `baud` | A number specifying the baud rate of the connection. This property is required.

If both `rx` and `tx` are unspecified, a `TypeError` is thrown by the constructor during validation.

#### Methods

**`read([byteLength])`**

When using the `buffer` data format, `calling` read with no arguments returns all bytes available. The number of bytes to read may be passed. If fewer bytes are available than requested, only the bytes available are returned -- no exception is thrown and the `read` call does not wait for additional data to arrive.

<!-- perhaps read with no arguments should allow the implementation to decide the number of bytes to return instead of requiring "all" -- which could be ambiguous (more data arrived since onReadable and may cause memory allocation failures -->

**`flush([input, output])`**

Flushes the input and/or output queues of the serial instance. If no arguments are passed, both input and output queues are flushed. If both arguments are provided, the corresponding queues are flushed based on the value of the arguments. An exception is thrown if one argument is passed.

**`set(options)`**
The `set` method controls the value of the RTS and DTR pins of the serial connection together with the break. The sole argument is an options object which contains optional `dtr`, `rts`, and `break` properties with boolean values.

If `dtr`, `rts`, or `break` is not specified in the dictionary, the corresponding serial behavior is left unchanged.

<!--
**`get(options)`**

-->

#### Callbacks

**`onReadable(bytes)`**

The `onReadable` callback is invoked when new data is available to read. The callback receives a single argument that indicates the number of bytes available.

**`onWritable(bytes)`**

The `onWritable` callback is first invoked when the serial instance is ready for use.

The `onWritable` callback is invoked when space has been freed in the output buffer. The callback receives a single argument that indicates the number of bytes that may be written without overflowing the output buffer.

#### Data Format
The data format is either `number` for individual bytes, or `buffer` for groups of bytes. The default data format is `number`. When using the `buffer` format, the `write` call accepts an `ArrayBuffer` or a `TypedArray`, and the `read` call always returns an `ArrayBuffer`.

### Wakeable Digital
The `WakeableDigital` class represents a digital input source used in energy management. 

```js
import WakeableDigital from "tc53:io/wakeabledigital";
```

The Wakeable Digital pin indicates if the most recent boot of the microcontroller was caused by a change on the specified input bringing the device out of sleep. It works for both deep sleep (e.g. device shuts down on sleep and resets when waking) and light sleep (e.g. device pauses execution when sleeping and resumes on wake).

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `pin` | A pin that may cause the device to wake from sleep

#### Callbacks

**`onReadable()`**

Invoked following instantiation if the device was woken from sleep by the specified pin.

#### Data Format
The Wakeable Digital IO always uses a data format of `number`. A value of 0 indicates the device did not wake from sleep and a value of 1 indicates that it did.

### SPI

The `SPI` class implements a Serial Peripheral Interface (SPI) host to communicate with a single SPI peripheral.

<!-- The master/slave MOSI/MISO terminology is pretty baked into SPI. But I think host/peripheral is just as clear and does have some (limited) precedent. I'm trying it here for now. -AJC -->

```js
import SPI from "tc53:io/spi";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
|  `out` | The Host Out / Peripheral In pin. This property is required when using the SPI bus to write data.
|  `in` | The Host In / Peripheral Out pin. This property is required when using the SPI bus to read data.
|  `clock` | The clock pin. This property is required.
|  `select` | The chip select pin. This property is optional and should not be specified if chip select will be managed by the caller.
|  `active` | Must be 1 or 0. Specifies the value to write to the `select` pin when the SPI instance is active. This property is optional and defaults to 0. 
|  `hz` | The speed of communication on the SPI bus. This property is required.

If both `out` and `in` are unspecified, a `TypeError` is thrown by the constructor during validation. 

The `in` and `out` properties may refer to the same physical pin in the case of 3-wire SPI.

<!-- I have suggested `mode` as a standard optional property that defaults to 0 in the past. But I'm not certain that every host supports setting SPI mode, so perhaps that's best left to individual implementations. -AJC -->

#### Data Format
The data format for SPI is always a buffer. The `write` and `transfer` calls accept an `ArrayBuffer` or a `TypedArray`. The `read` and `transfer` calls always return an `ArrayBuffer`. 

<!-- This description currently ignores the issue of transferring in non-8-bit blocks. It is obscure, for sure, and not supported by every host. But perhaps it should be mentioned as an option for the format? Transfer is common. Transfer in the form of "write n bits then read k bits" is sometimes done. But I've personally never seen it done in a way that required a non-byte-aligned number of bits in the overall transfer.-->

<!--
This text seems to restate the definition of SPI. Maybe it does not need to be said?

#### Chip Select

Implementations of the `read`, `write`, and `transfer` methods must ensure that the `select` pin is set to `active` before reading from or writing to the SPI bus. If no `select` pin was specified, the caller is responsible for managing the state of any chip select logic.
-->

#### Methods

**`read(byteLength)`**

Read and return `byteLength` bytes from the SPI bus as an `ArrayBuffer`. The behavior of the Host Out / Peripheral In pin is implementation-dependent.

**`write(buffer)`**

Write `buffer` to the SPI bus. Any input data is discarded.

<!-- the presence of onWritable implies that this is asynchronous but that isn't explicit here. It seems dangerous to make it async from script. I don't know how to do that reliably without a copy in XS. We should be explicit about whether we expect the buffer copy. Also... a synchronous write is needed even if async is supported -- setting display registers is always sync, only the display data is async. Otherwise it would be very complex to configure. -->

**`transfer(buffer)`**

Write `buffer` to the SPI bus while simultaneously reading and returning `buffer.length` bytes from the SPI bus as an `ArrayBuffer`.

<!-- maybe an optional read buffer argument? ... that would also solve the bit problem... you can have buffer.bitLength be an option on each buffer. So read and write use bytes and transfer is the advanced call with a bit option. -->

**`flush([deselect])`**

Synchronously flushes any buffers of the SPI host instance. The flush operation is synchronous and completes before returning.

Some SPI peripherals require the chip select pin be set inactive at specific times (for instance, to mark the end of a transaction). The `flush` method supports this with the optional `deselect` argument which, when present and  `true`, causes the chip select pin is set to inactive after thee flush completes. 

#### Callbacks

**`onWritable()`**

The `onWritable` callback is first invoked when the SPI instance is ready for use.

The `onWritable` callback is subsequently invoked when a SPI transaction completes.

### TCP Socket
The `TCP` network socket class implements a general purpose, bi-directional TCP connection. 

```js
import TCP from "tc53:io/socket/tcp";
```

The TCP socket is not a TCP listener, as in some networking libraries. The TCP listener is a separate class.

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `address` | A string with the IP address of the remote endpoint to connect to. Either the `address` or `host` property must be provided.
| `host` | A string with the DNS name of the remote endpoint to connect to. Either the `address` or `host` property must be provided.
| `port` | A number specifying the remote port to connect to. This property is required.
| `nodelay` | A boolean indicating whether to disable Nagle's algorithm on the socket. This property is equivalent to the `TCP_NODELAY` option in the BSD sockets API. This property is optional and defaults to false.
| `keep-alive` | A number specifying the keep-alive interval of the socket in milliseconds. This property is optional and if not present, the `keep-alive` capability of the socket is not used.
| `from` | An existing TCP socket instance from which the native socket instance is taken to use with the newly created socket instance. This property is optional and intended for use with a TCP listener. When the `from` property is present, the `address`, `host`, and `port` properties are not required, and are ignored if specified.

#### Callbacks

**`onReadable(bytes)`**

Invoked when new data is available to be read. The callback receives a single argument that indicates the number of bytes available to read.

**`onWritable(bytes)`**

Invoked when space has been made available to output additional data. The callback receives a single argument that indicates the total number of bytes that may be written to the TCP socket without overflowing the output buffers.

The `onWritable` callback is invoked When the socket successfully connects to the remote host and it is possible to write data.

**`onError`**

The `onError` callback is invoked when an error occurs or the TCP socket disconnects. Once `onError` is invoked, the connection is no longer usable. Reporting the error type is an area for future work.

#### Data Format
The data format is either `number` for individual bytes, or `buffer` for groups of bytes. The default data format is `buffer`. When using the `buffer` format, the `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.

### TCP Listener Socket
The TCP `Listener` class listens for and accepts incoming TCP connection requests.

```js
import Listener from "tc53:io/socket/listener";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `port` | A number specifying the port to listen on. This property is optional.
| `address` | A string with the IP address of the network interface to bind to. This property is optional.

#### Methods

**`read()`**
The `read` function returns a `TCP` Socket instance. The instance is already connected to the remote host. There are no callback functions installed.

> **Note**: To set the callbacks and configure the socket, pass the socket to the `TCP` Socket constructor using the `from` property.

**`write()`**

Unsupported.

#### Callbacks

**`onReadable(requests)`**

Invoked when one or more new connection requests are received. The callback receives a single argument that indicates the total number of pending connection requests.

#### Data Format
The TCP `Listener` class uses `socket/tcp` as its sole data format.

### UDP Socket
The `UDP` network socket class implements the sending and receiving of UDP packets. 

```js
import UDP from "tc53:io/socket/udp";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `port` | The local port number to bind the UDP socket to. This property is optional.
| `address` | A string with the IP address of the network interface to bind to. This property is optional.
| `multicast` | A string with the IP address of a multicast address to bind to. This property is optional.
| `ttl` | A number with the multicast time-to-live value as a number from 1 to 255. This property is required if the `multicast` property is provided and otherwise ignored.

#### Methods

**`read()`**
The `read` call returns a complete UDP packet as an `ArrayBuffer`. The returned packet data has the following properties attached to it: 

- `address`, a string containing the packet sender's IP address
- `port`, the port number used to send the packet.

**`write(address, port, packet)`**
The `write` call takes three arguments: remote address string, remote port number, and the packet data as an `ArrayBuffer` or `TypedArray`. If there is insufficient memory to transmit the packet, the `write` call throws an exception.

#### Callbacks

**`onReadable(packets)`**

Invoked when one or more packets are received. The callback receives a single argument that indicates the total number of packets available to read.

#### Data Format
The data format is always `buffer`. The `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.


<a id="io-providers"></a>
## 9 IO Providers



<a id="sensor-class-pattern"></a>
## 10 Sensor Class Pattern

The Sensor Class Pattern builds on the Base Class Pattern to provide a foundation for implementing access to a variety of sensors.

It is anticipated, but not required, that instances conforming to the Sensor Class Pattern will be implemented using instances conforming to the IO Class Pattern. The Sensor Class Pattern therefore are non-blocking, like IO. Additionally, the constructor re-uses the hardware specifiers for the hardware IO types they use.

The Sensor Class Pattern is for implementing low level sensor access, similar to a sensor driver provided by a sensor manufacturer. The goal is to be able to provide access to all the unique capabilities of the sensor. As with IO, where a given type of device (e.g. a temperature sensor) have common capabilities across manufacturers, the individual sensor types define a common way to access that functionality.

Higher level sensor APIs may be built using instances of the Sensor Class Pattern. The W3C Generic Sensor specification, for example, may be implemented using sensor conforming to The Sensor Class Pattern.

The Sensor Class Pattern may be used together with the Sensor Data Provence Rules to improve the usability of the data collected.

### `constructor`

Following the Base Class Pattern, the constructor has a single options object argument. The options object defines the hardware connections of the sensor. These use the same properties as the IO types corresponding to the hardware connection. For example, an I²C temperature sensor:

	let t = new Temperature({
		sda: 4,
		scl: 5,
		address: 0x30
	});

If the sensor has multiple hardware connections the options object separates them to avoid collisions. For example, here the temperature sensor has an interrupt on a Digital pin:

	let t = new Temperature({
		sensor: {
			sda: 4,
			scl: 5,
			address: 0x30
		},
		interrupt: {
			pin: 5
		}
	});

The constructor must reset the hardware to a known initial state, so that the sensor's behavior is not dependent on a previous instantiation. This reset may include calling the instance's `configure` method.

### `configure` method

The `configure` method defines how the sensor operates. This may include the hardware's sampling interval, what data is sampled, and the range of the data sampled. 

The `configure` method has a single argument, an options object.

The `configure` method follows the same rules regarding the options argument as the `constructor` and therefore may not modify its content.

As sensors have many options, the `configure` method may implement support for many properties. A given call to `configure` method should only modify the configuration properties included in the options object. 

Calling the `configure` method is not required for use of the sensor when the default configuration is adequate.

The `configure` method may be called more than once to allow scripts to reconfigure the sensor.

### `sample` method

The `sample` method returns readings from the sensor. The Sensor Class Pattern defines no arguments for the `sample` method, though individual sensor types may.

The `sample` method returns an object containing one or more properties. The returned object is mutable. The implementation must return a different object on each invocation to allow calls to accumulate multiple sensor readings.

> Note: A sensor implementation of `sample` may accept an input argument of the object to use for the sensor data as an optimization to reduce memory manager work.

If the sample data includes one or more time stamps that indicate when the sample was collected, those timestamps in the returned sample object should conform to the Sensor Data Provence Rules.

<a id="sensor-classes"></a>
## 11 Sensor Classes

<a id="pixel-display-class-pattern"></a>
## 12 Pixel Display Class Pattern

<a id="sensor-data-provence-rules"></a>
## 13 Sensor Data Provence Rules

