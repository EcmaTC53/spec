<p id="subtitle">TC53 DRAFT / June 22, 2020</p>
<p id="title">ECMAScript® Modules for Embedded Systems</p>

<img src="./assets/ecma-logo.svg">

<a id="introduction"></a>
## Introduction

The TC53 specification defines APIs for use on embedded systems. Embedded systems are far more diverse than personal computers, smart phones, and web servers where ECMAScript is most widely used. The diversity of embedded hardware is a consequence of devices being optimized for a specific product or class of products.

It is not enough for the TC53 APIs to support the features embedded systems have in common. To be truly useful, they must allow access to the unique hardware capabilities of each embedded system. This requirement makes this specification very different from thata of a computer language which is grounded in the formality and rigor of mathematics. Hardware can be inconsistent, even sometimes messy, but it needs to be accommodated. 

The ability for scripts to access unique hardware capabilities has an important consequence. It means that not all correct scripts will run correctly on all hardware. If a script requires a feature that is unavailable, it cannot run. While it is common in ECMAScript to use a "polyfill" to emulate missing language and runtime features, this is usually impractical, if not impossible, for hardware capabilities. Therefore, the goal of this specification is to make it possible to write portable scripts for specific operations, not to guarantee that all scripts execute correctly on any conformant deployment.

One important consideration when designing hardware products is cost. The APIs are designed to allow efficient execution with minimal resource use. They assume no minimum or maximum configuration. Advances in the state-of-the art of ECMAScript engines, microcontrollers, and runtime libraries will determine where these APIs may be used.

This specification is influenced by the Extensible Web Manifesto. It aims to provide low level APIs that do things -- primarily related to hardware and communication -- that the ECMAScript language cannot do by itself. These low-level APIs are functional, simple, and efficient. The APIs may be used directly. However, it is expected that many developers will interact with them indirectly through higher level modules and frameworks that build upon the low-level APIs. This layered approach keeps the low-level APIs small and focused while allowing a variety of uses and API styles to be build on them.

### ECMAScript

This specification builds on Standard ECMAScript as defined by Ecma TC39. As of this writing, that is ECMAScript 2020.

This specification is not an extension or subset of ECMAScript 2020. It is a set of APIs to be used within that specification. The relationship between TC53 and ECMAScript is analogous to the relationship between ECMAScript Internationalization API (ECMA 402) and ECMAScript.

This specification is intended to be used in strict mode only. Sloppy mode has known issues that detract from building a robust system. Sloppy mode is maintained primarily for web compatibility and provides no benefit to embedded systems.

### Class Patterns

A Class Pattern, as used in this specification, is combination of requirements and guidelines for a class. For example, the IO Class Pattern defines behaviors for all IO classes.

TC53 defines classes in terms of Class Patterns. In the future, there may be true formal classes as found in the ECMAScript Language.

Requirements of a Class Pattern are behaviors specified by TC53 and must be adhered to for a conformant implementation. A Class Pattern can be seen as similar to a collection of Abstract Operations in the ECMA-262.

Guidelines are primarily for extensibility. Extensibility is essential to TC53 as unique hardware capabilities must be possible to access. Extensibility is problematic because of the potential for collisions. This specification provides requirements for how extensibility may be implemented.

Unless stated, there are no requirements about class inheritance. An implementation of a class pattern may inherit from `Object` or any other class, so long as it conforms.

### Independent Implementations

This specification is intended to facilitate multiple independent implementations of the APIs. A given API may warrant an entirely different implementation depending a variety of factors that include the host hardware, operating system, and ECMAScript engine.

### Self-Hosting

The ECMAScript language is defined in terms of a host that provides the runtime environment for execution of scripts. This specification does not change that. The APIs defined herein are provided by a host. However, this specification does anticipate that portions of the runtime environment provided by the host may themselves be implemented in ECMAScript. This specification refers to a host that includes some ECMAScript code in its implementation as self-hosting.

One challenge of self-hosting is keeping the host fully separated from the scripts, to avoid problems including security, robustness, and compatibility. The Compartment model defined as part of the Secure ECMAScript proposal provides a solution for separating hots scripts and hosted scripts.

Self-hosted implementations must ensure that no internal properties or methods are visible to client scripts using the implementation. Private fields and private methods are a way to shield internal properties and methods from client code, but their use is not required.

> **Note**: Self-hosting is not required.

<!--
### Immutability

Immutability of object properties is a feature of ECMAScript. It is not widely used, however. Immutability is valuable for embedded systems and consequently this specification makes use of it in several ways.

- Data may be stored in read-only memory, reducing the RAM required for execution
- Improving secure as they are inherently resistant to tampering
- Simplifying implementation, as in...

-->

### Module Specifiers

This specification specifies classes which are accessed through modules. Because many embedded systems lack a file system, using file paths to access modules is impractical and contrived. Instead, modules are accessed using bare module specifiers. While such specifiers are currently forbidden in a web browser, they are permitted in other environments.

To avoid naming collisions with bare module specifiers, a namespace prefix has been [proposed](https://github.com/tc39/proposal-built-in-modules#namespace). This specification uses a single namespace prefix (currently "tc53:" but expected to change). For example,

	import Digital from "tc53:io/digital";

For avoidance of doubt, the use of bare module specifiers by this specification does not prevent an engine from also providing support for other kinds of module specifiers.

### Secure ECMAScript

Secure ECMAScript (SES) is a proposal to extend the language to support provably secure execution of scripts in an environment that includes both trusted and untrusted scripts. The two foundations of Secure ECMAScript are immutability and compartments. SES makes all primordials immutable prior to execution of any script code. This ensures all built-in object behave as defined by the language, disables common attack vectors, and eliminates communication side-channels. Compartments allow one script to sandbox other scripts to limit the globals and modules that are available in the sandbox.

The security guarantees provided by SES are valuable for building large systems that contains code from many sources, not all of which may be fully trusted. The mechanisms proposed by SES allow for an efficient implementation. Further, the immutability requirement for SES allows primordials to be stored in read-only memory, reducing RAN use and allowing them to be securely shared by multiple virtual machines.

This specification is designed to be used with SES when a runtime security solution is required. If and when the SES proposal is an approved standard, this specification will reference it normatively.

SES consists of two major execution phases - pre-lockdown and post-lockdown. Prior to lockdown primordials are mutable and Compartments are unavailable. A TC53 host is not required to support pre-lockdown on the host hardware. A host may complete lockdown during the build process, for example.

<a id="scope"></a>
## 1 Scope

This Standard defines the application programming interface for ECMAScript modules that support programs executing on embedded systems. 

<a id="conformance"></a>
## 2 Conformance


<a id="normative-references"></a>
## 3 Normative References

The following referenced documents are required for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.

ECMAScript Language Specification (ECMA-262 10<sup>th</sup> Edition, or successor).<br>
    <a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a>

> NOTE: Throughout this document, the phrase &ldquo;ES2020, _x_&rdquo; (where x is a sequence of numbers separated by periods) may be used as shorthand for "ECMAScript Language Specification (ECMA-262 10<sup>th</sup> Edition, sub clause _x_)".

  
<a id="notational-conventions"></a>
## 4 Notational Conventions
    
<a id="requirements"></a>
## 5 Requirements for Standard Built-in ECMAScript Objects

Unless specified otherwise in this document, the objects, functions, and constructors described in this standard are subject to the generic requirements and restrictions specified for standard built-in ECMAScript objects in the ECMAScript Language Specification, 10th edition, clause [17](https://tc39.es/ecma262/#sec-ecmascript-standard-built-in-objects), or successor. 

<a id="base-class-pattern"></a>
## 6 Base Class Pattern

The Base Class Pattern defines common behaviors used for use by other class patterns. The  Base Class Pattern is purely abstract and cannot be instantiated directly.

Classes conforming to the Base Class Pattern may be subclassed.

### `constructor`

The constructor of the Base Class Pattern takes an options object (sometimes called a dictionary) as its first argument.

Only the `target` properties is defined in options object by the Base Class Pattern. 

Typically there are no other arguments as additional configuration options can and should be added to the options object. However, additional arguments are not prohibited.

It is an error to invoke the constructor without the options object. An exception will be thrown.

The implementation of the constructor should validate all supported option properties before allocating any resources. This behavior avoids enabling or changing the state of any hardware should the constructor fail due to invalid parameters.

The implementation must ignore any unrecognized option properties.

If the constructor fails to complete execution successfully, it must release any resources allocated prior to exiting.

The constructor must not modify the options object. It must acceept an immutable options object.

Once the instance has been successfully constructed, it must not be eligible for garbage collection until explicitly released by calling `close`. This is done so scripts do not need to maintain a reference to the object to prevent it from being collected, similar to `setInterval`/`clearInterval` and the W3C Generic Sensor specification.

### `close` method

The `close` method releases all resources associated with the instance.

Once `close` completes, the object is eligible for garbage collection.

Once `close` completes, an `Error` exception is thrown if any other instance methods are called. (Note: should a better error be defined for this?) It is not an error to call the `close` method more than once.

No callbacks may be invoked after the `close` method is called.

### `target` property

The `target` property is opaque to the object's implementation. It may be initialized by the constructor using the `target` property in the options object. Scripts may both read and write the target property, though it is typically only set at construction.

### Callbacks

Instances of the Base Class Pattern typically use function callbacks to deliver asynchronous events. 

Callback functions are provided to the instance as properties in the options object. 

	new Button({
		onPush() {
		},
		onRelease() {
		}
	});

Callback functions are invoked with `this` set to the instance. This can be overridden using standard ECMAScript features, such as arrow functions:

	new Button({
		onPush: () => {
		},
		onRelease: () => {
		}
	});

The callbacks are stored internally by the implementation. They are not public methods. The callback functions cannot be read and are only set using the constructor's options object. 

A callback function may only be invoked when no script is running in its host virtual machine to respect the [single-thread evaluation semantics of ECMAScript](https://tc39.es/ecma262/#sec-happens-before). This mean that callbacks may not be invoked by the instance from within its public method calls, including the constructor.

Callbacks must be invoked in the same virtual machine in which they were created. 

### Naming

The Base Class Pattern uses the camel-case naming convention for property names.

It follows the usual ECMAScript convention of naming classes with an initial capital letter and methods with an initial lower case letter.

Callback function names begin with `on`.

<a id="io-class-pattern"></a>
## 7 IO Class Pattern

The IO Class Pattern builds on the Base Class Pattern to provide a foundation for implementing access to a variety hardware inputs and outputs.

All IO is non-blocking, consistent with ECMAScript API behavior on the web platform. That said, not all operations are instantaneous. Implementations determine how long is too long for a given operation.

Non-blocking IO is facilitated by two callback functions, `onReadable` and `onWritable`, which eliminate the need for polling in most cases.

### constructor

The options object contains the specification of the hardware resources to be used by the instance. For example, a digital output has a `pin` property to indicate the physical pin to use.

The value of the `pin` property is implementation dependent. It is often a number corresponding to the logical GPIO pin number as per the hardware data sheet (e.g. GPIO 5), but it may be a string ("D1") or even an object ({port: 1, pin: 5}). Some IO classes use more than one pin, such as I²C which has clock and data pins. These may have the same kinds of values as a the `pin` property.

If thee constructor is called for a hardware resource that is already in use -- whether by a script or the native host -- an `Error` exception is thrown. (Note: better error?)

This specification allows, but does not require, an implementation to open multiple instances for the same hardware resource, if the instances cannot interfere with each other's operation. For example, this can work for a digital input  but would not for a digital output.

The IO Class Pattern is designed to be used both with IO types that have only a current value (e.g. Digital, analog, PWM) and IO types use streams of data (e.g. serial, SPI).

### `read` method

The `read` method returns data from the IO instance. If no data is available, it returns `undefined`.  The type of the data returned depends on the value of the `format` property.

The `read` method may take any number of arguments, including zero. The arguments are defined by the specific IO type.

If this instance does not support reading (because the IO type cannot be read or because it is configured for write-only) an Error exception is thrown.

### `write` method

The `write` method sends data to the IO instance.

If the device cannot accept the data because its buffers are full or the data is incompatible, an `Error` exception is thrown.

The `write` method may take any number of arguments, including zero. The arguments are defined by the specific IO type. The type of data accepted by `write` depends on the value of the `format` property.

If this instance does not support writing (because the IO type cannot be written or because it is configured for read-only) an Error exception is thrown.

### `format` property

The `format` property is a string that indicates the type of data used by the `read` and `write` methods. It is initialized by the constructor to the default defined for its IO type. The `format` property may be set by the script at any time to change how it reads and writes data.

The following values are defined by the IO Class Pattern for the `format` property. IO types may choose to support one or more, and may define others.

- `number` - an ECMAScript number value, typically used for bytes
- `buffer` - an `ArrayBuffer` instance
- `string;ascii` - an ECMAScript string from a 7-bit ASCII source
- `string;utf8` - an ECMAScript string from a UTF-8 source

The `format` property is implemented as a getter and setter. Attempting to set the `format` property to an unsupported value throws an `Error` exception and does not change the value.

### Callbacks

The IO Class Pattern specifies three callbacks which are set by the options object passed to the constructor. Most IO types operate with or without these callbacks installed, but a particular IO type may require one or more callbacks.

#### onReadable

The `onReadable` callback is invoked when the instance has data available to be read. Data is retrieved using the `read` method.

The `onReadable` callback may receive one or more arguments with information about the data available to read. The arguments are defined by the specific IO type.

The `onReadable` callback is invoked once when data arrives and not again until additional data is available to read.

#### onWritable

The `onWritable` callback is invoked when the instance is able to accept more data for output.

The `onWritable ` callback may receive one or more arguments with information about amount of data that may be written. The arguments are defined by the specific IO type.

#### onError

The `onError` callback is invoked when a non-recoverable error occurs. The instance is no longer usable. The only method that should be called is `close`.

Details of the error may be passed to the callback using arguments defined by the specific IO type.

<a id="io-classes"></a>
## 8 IO Classes

This section defines the IO Classes based on the IO Class Pattern.

The classes support capabilities commonly supported by hardware and runtimes. Capabilities that are not supported here may be added using the extensibility options of the IO Class Pattern and Base Class Pattern.

### Digital

The `Digital` IO class is used for digital inputs and outputs.

```js
import Digital from "tc53:io/digital";
```

#### Constructor Properties

| Property | Description |
| :---: | :--- |
| `pin` | A number from 0 to 16 indicating the pin number to control. This property is required. |
| `mode` |A value indicating the mode of the IO. May be `Digital.Input`, `Digital.InputPullUp`, `Digital.InputPullDown`, `Digital.InputPullUpDown`, `Digital.Output`, or `Digital.OutputOpenDrain`. This property is required. |
|`edge` | A value indicating the conditions for invoking the `onReadable` callback. Values are `Digital.Rising`, `Digital.Falling`, and `Digital.Rising | Digital.Falling`. This value is required if `onReadable` is present and ignored otherwise.

#### Callbacks

**`onReadable()`**

Invoked when the input value changes depending on the value of the `mode` property.

#### Data Format
The `Digital` class data format is always `number` with a value of either 0 or 1.

#### Notes
A digital IO instance configured as an input does not implement write; one configured as an output does not implement read.

### DigitalBank
The `DigitalBank` class provides simultaneous access to a group of digital inputs or outputs.

```js
import DigitalBank from "tc53:io/digitalbank";
```

#### Constructor Properties

| Property | Description |
| :---: | :--- |
| `pins` |A bit mask with pins to include in the bank set to 1. For example, the bit mask for a bank to access pins 2 and 3 is 0x0C (0b1100). This property is required.
| `mode` | A value indicating the mode of the IO, May be `Digital.Input`, `Digital.InputPullUp`, `Digital.InputPullDown`, `Digital.InputPullUpDown`, `Digital.Output`, or `Digital.OutputOpenDrain`. All pins in the bank use the same mode. This property is required.
| `rises` | A bit mask indicating the pins in the bank that should trigger an  `onReadable` callback when transitioning from 0 to 1. When an `onReadable` callback is provided, at least one pin must be set in `rises` and `falls`.
| `falls` | A bit mask indicating the pins in the bank that should trigger an  `onReadable` callback when transitioning from 1 to 0. When an `onReadable` callback is provided, at least one pin must be set in `rises` and `falls`.

#### Callbacks

**`onReadable(triggers)`**

Invoked when the input value changes depending on the value of the `mode`, `rises`, and `falls` properties. The `onReadable` callback receives a single argument, `triggers`, which is a bit mask indicating each pin that triggered the callback with a 1.

#### Data Format
Thee data format is always `number`. The value is a bit mask. On a read operation, any bit positions that are not included in the `pins` bit mask are set to 0.

> **Note**: This requirement prevents leaking the state of reserved pins and pins used by another bank.

#### Notes
A digital IO bank instance configured as an input does not implement write; one configured as an output does not implement read.

### Analog Input
The `Analog` IO class represents an analog input source.

```js
import Analog from "tc53:io/analog";
```

#### Constructor Properties

| Property | Description |
| :---: | :--- |
|  `pin` | The number of the analog input. This property is required.
|  `resolution` | The requested number of bits of resolution of the input. This property is optional.

#### Data Format
The data format is always a number. The value returned is an integer from 0 to a maximum value based on the resolution of the analog input.

#### `resolution` property
The read-only `resolution` property indicates the number of bits of resolution provided in values returned by the instance.

### PWM
The `PWM` IO class provides access to the pulse-width modulation capability of pins.

```js
import PWM from "tc53:io/pwm";
```

#### Constructor Properties

| Property | Description |
| :---: | :--- |
|  `pin` | A number from 0 to 16 indicating the GPIO number to operate as a PWM output. This property is required.
|  `hz` | A number specifying the requested frequency of the PWM output in Hz. This property is optional.

#### Data Format
The data format is always a number. The `write` call accepts integers between 0 and a maximum value based on the resolution of the PWM output.

#### `resolution` property
The read-only `resolution` property indicates the number of bits of resolution in values passed to the `write` method.

#### `hz` property
The read-only `hz` property returns the frequency of the PWM.

#### Notes
A PWM instance defaults to a duty cycle of 0% until `write` is called with a different value.

### I²C
The `I2C` class implements an I²C Initiator to communicate with an I²C Peripheral over I²C bus.

<!-- normative reference to  I²C? -->

```js
import I2C from "tc53:io/i2c";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `data` | The I²C data pin. This property is required.
| `clock` | The I²C clock pin. This property is required.
| `hz` | The speed of communication on the I²C bus. This property is required.
| `address` | The 7-bit address of the target I²C Peripheral to communicate with. This property is required.

#### Data Format
The data format is always a buffer. The `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.

#### Specifying Stop Bit with `read` and `write` Methods
The I²C protocol is transaction-based. At the end of each read and write operation, a stop bit is sent. If the stop bit is 1, it indicates the end of the transaction; if 0, it indicates that the transaction has additional operations pending.

The `read` and `write` methods set the stop bit to 1 by default. An optional second argument to the `read` and `write` methods allows the stop bit to be specified. Pass `false` to set the stop bit to 0, and `true` to set the stop bit to 1. 

### SMBus
The `SMBus` class is extends the `I2C` class with additional methods to communicate with devices that implement the SMBus protocol.

<!-- normative reference to  SMBus? -->

```js
import SMBus from "tc53:io/smbus";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `stop` | A boolean value indicating whether to set the stop bit when writing the SMBus register number. This property is optional and defaults to `false`.

#### Methods
**`readUint8(register)`**

Reads and returns an unsigned 8-bit integer value from the specified register.

**`writeUint8(register, value)`**

Writes the unsigned 8-bit integer `value` to the specified register.

**`readUint16(register[, bigEndian])`**

Reads and returns an unsigned 16-bit integer value from the specified register. By default the value is read in little-endian byte order. If the optional `bigEndian` value is set to `true` the value is read in big-endian byte order.

**`writeUint16(register, value[, bigEndian])`**

Writes the unsigned 16-bit integer value to the specified register. By default the value is written in little-endian byte order. If the optional `bigEndian` value is set to `true` the value is written in big-endian byte order.

**`readBuffer(register, buffer)`**

Reads a stream of bytes starting at the specified `register` into the `ArrayBuffer` instance in the `buffer` argument . The number of bytes read is equal to the `byteLength` of the buffer.

**`writeBuffer(register, buffer)`**

Write a stream of bytes from the `ArrayBuffer` instance in the `buffer` argument starting at the specified `register`. The number of bytes read is equal to the `byteLength` of the buffer.

### Serial
The `Serial` class implements bi-directional serial (UART) communication.

```js
import Serial from "tc53:io/serial";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
|  `receive` | The receive pin. This property is required when using the serial connection to read data.
|  `transmit` | The transmit pin. This property is required when using the serial connection to write data.
| `baud` | A number specifying the baud rate of the connection. This property is required.

If both `receive` and `transmit` are unspecified, a `TypeError` is thrown by the constructor during validation.

#### Methods

**`read([byteLength])`**

When using the `buffer` data format, `calling` read with no arguments returns all bytes available. The number of bytes to read may be passed. If fewer bytes are available than requested, only the bytes available are returned -- no exception is thrown and the `read` call does not wait for additional data to arrive.

<!-- perhaps read with no arguments should allow the implementation to decide the number of bytes to return instead of requiring "all" -- which could be ambiguous (more data arrived since onReadable and may cause memory allocation failures -->

**`flush([input, output])`**

Flushes the input and/or output queues of the serial instance. If no arguments are passed, both input and output queues are flushed. If both arguments are provided, the corresponding queues are flushed based on the value of the arguments. An exception is thrown if one argument is passed.

**`set(options)`**
The `set` method controls the value of the RTS and DTR pins of the serial connection together with the break. The sole argument is an options object which contains optional `dtr`, `rts`, and `break` properties with boolean values.

If `dtr`, `rts`, or `break` is not specified in the dictionary, the corresponding serial behavior is left unchanged.

<!--
**`get(options)`**

-->

#### Callbacks

**`onReadable(bytes)`**

The `onReadable` callback is invoked when new data is available to read. The callback receives a single argument that indicates the number of bytes available.

**`onWritable(bytes)`**

The `onWritable` callback is first invoked when the serial instance is ready for use.

The `onWritable` callback is invoked when space has been freed in the output buffer. The callback receives a single argument that indicates the number of bytes that may be written without overflowing the output buffer.

#### Data Format
The data format is either `number` for individual bytes, or `buffer` for groups of bytes. The default data format is `number`. When using the `buffer` format, the `write` call accepts an `ArrayBuffer` or a `TypedArray`, and the `read` call always returns an `ArrayBuffer`.

### Wakeable Digital
The `WakeableDigital` class represents a digital input source used in energy management. 

```js
import WakeableDigital from "tc53:io/wakeabledigital";
```

The Wakeable Digital pin indicates if the most recent boot of the microcontroller was caused by a change on the specified input bringing the device out of sleep. It works for both deep sleep (e.g. device shuts down on sleep and resets when waking) and light sleep (e.g. device pauses execution when sleeping and resumes on wake).

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `pin` | A pin that may cause the device to wake from sleep

#### Callbacks

**`onReadable()`**

Invoked following instantiation if the device was woken from sleep by the specified pin.

#### Data Format
The Wakeable Digital IO always uses a data format of `number`. A value of 0 indicates the device did not wake from sleep and a value of 1 indicates that it did.

### SPI

The `SPI` class implements a Serial Peripheral Interface (SPI) host to communicate with a single SPI peripheral.

<!-- normative reference needed... if possible -->
<!-- I'm not aware of a normative specification for SPI. It is common to see individual manufacturers publish a SPI standard for a family of parts. Examples include: Microchip http://ww1.microchip.com/downloads/en/DeviceDoc/70067b.pdf, VTI https://www.mouser.com/pdfdocs/tn15_spi_interface_specification.PDF, and Cypress https://www.cypress.com/file/132086/download. But there's nothing normative about any of those beyond their individual component families. -->

```js
import SPI from "tc53:io/spi";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
|  `out` | The Host Out / Peripheral In pin. This property is required when using the SPI bus to write data.
|  `in` | The Host In / Peripheral Out pin. This property is required when using the SPI bus to read data.
|  `clock` | The clock pin. This property is required.
|  `select` | The chip select pin. This property is optional and should not be specified if chip select will be managed by the caller.
|  `active` | The value to write to the `select` pin when the SPI instance is active. Must be 1 or 0. This property is optional and defaults to 0. 
|  `hz` | The speed of communication on the SPI bus. This property is required.
|  `mode` | The SPI bus mode, a two-bit mask that specifies the SPI clock polarity (bit 1) and phase (bit 0). This property is optional and defaults to 0b00.

If both `out` and `in` are unspecified, a `TypeError` is thrown by the constructor during validation. 

The `in` and `out` properties may refer to the same physical pin (e.g. 3-wire SPI).

#### Data Format
The data format for SPI is always a buffer. The `read`, `write` and `transfer` calls accept an `ArrayBuffer` or a `TypedArray`. The `read` and `transfer` calls always return an `ArrayBuffer`. 

#### Methods

**`read(buffer)`**

Read `buffer.byteLength` 8-bit bytes from the SPI bus into `buffer` and return `buffer`. The behavior of the Host Out / Peripheral In pin is implementation-dependent.

If the `buffer` argument has a `bitLength` property, it specifies the number of bits to read, overriding the `byteLength` property to allow reading of partial bytes. `buffer.bitLength` must be less than or equal to the number of bits in the buffer (i.e. `buffer.byteLength * 8`). Bits are read into the start of `buffer` (i.e. bit offset zero).

**`write(buffer)`**

Write `buffer` to the SPI bus. Any input data is discarded.

If the `buffer` argument has a `bitLength` property, it specifies the number of bits to write, overriding the `byteLength` property to allow writing of partial bytes. `buffer.bitLength` must be less than or equal to the number of bits in the buffer (i.e. `buffer.byteLength * 8`). Bits are written from the start of  `buffer` (i.e. bit offset zero).

**`transfer(buffer)`**

Write `buffer` to the SPI bus while simultaneously reading `buffer.byteLength` 8-bit bytes from the SPI bus. The results of the read are placed into `buffer`, replacing the original contents, and returned.

If the `buffer` argument has a `bitLength` property, it specifies the number of bits of the buffer to swap in the transfer, overriding the `byteLength` property to allow transfer of partial bytes. `buffer.bitLength` must be less than or equal to the number of bits in the buffer (i.e. `buffer.byteLength * 8`). Bits are transferred from the start of `buffer` (i.e. bit offset zero).

**`flush([deselect])`**

Flushes any buffers of the SPI host instance. The flush operation is synchronous and completes before returning.

Some SPI peripherals require the chip select pin be set inactive at specific times (for instance, to mark the end of a transaction). The `flush` method supports this with the optional `deselect` argument which, when present and `true`, causes the chip select pin is set to inactive after the flush completes. 

### TCP Socket
The `TCP` network socket class implements a general purpose, bi-directional TCP connection. 

```js
import TCP from "tc53:io/socket/tcp";
```

The TCP socket is not a TCP listener, as in some networking libraries. The TCP listener is a separate class.

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `address` | A string with the IP address of the remote endpoint to connect to. Either the `address` or `host` property must be provided.
| `host` | A string with the DNS name of the remote endpoint to connect to. Either the `address` or `host` property must be provided.
| `port` | A number specifying the remote port to connect to. This property is required.
| `noDelay` | A boolean indicating whether to disable Nagle's algorithm on the socket. This property is equivalent to the `TCP_NODELAY` option in the BSD sockets API. This property is optional and defaults to false.
| `keepAlive` | A number specifying the keep-alive interval of the socket in milliseconds. This property is optional and if not present, the keep-alive capability of the socket is not used.
| `from` | An existing TCP socket instance from which the native socket instance is taken to use with the newly created socket instance. This property is optional and intended for use with a TCP listener. When the `from` property is present, the `address`, `host`, and `port` properties are not required, and are ignored if specified. The original instance is closed with ownership of the native socket is transferred to the new instance.

#### Callbacks

**`onReadable(bytes)`**

Invoked when new data is available to be read. The callback receives a single argument that indicates the number of bytes available to read.

**`onWritable(bytes)`**

Invoked when space has been made available to output additional data. The callback receives a single argument that indicates the total number of bytes that may be written to the TCP socket without overflowing the output buffers.

The `onWritable` callback is invoked When the socket successfully connects to the remote host and it is possible to write data.

**`onError`**

The `onError` callback is invoked when an error occurs or the TCP socket disconnects. Once `onError` is invoked, the connection is no longer usable. Reporting the error type is an area for future work.

#### Data Format
The data format is either `number` for individual bytes, or `buffer` for groups of bytes. The default data format is `buffer`. When using the `buffer` format, the `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.

### TCP Listener Socket
The TCP `Listener` class listens for and accepts incoming TCP connection requests.

```js
import Listener from "tc53:io/socket/listener";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `port` | A number specifying the port to listen on. This property is optional.
| `address` | A string with the IP address of the network interface to bind to. This property is optional.

#### Methods

**`read()`**
The `read` function returns a `TCP` Socket instance. The instance is already connected to the remote host. There are no callback functions installed.

> **Note**: To set the callbacks and configure the socket, pass the socket to the `TCP` Socket constructor using the `from` property.

**`write()`**

Unsupported.

#### Callbacks

**`onReadable(requests)`**

Invoked when one or more new connection requests are received. The callback receives a single argument that indicates the total number of pending connection requests.

#### Data Format
The TCP `Listener` class uses `socket/tcp` as its sole data format.

### UDP Socket
The `UDP` network socket class implements the sending and receiving of UDP packets. 

```js
import UDP from "tc53:io/socket/udp";
```

#### Constructor Properties
| Property | Description |
| :---: | :--- |
| `port` | The local port number to bind the UDP socket to. This property is optional.
| `address` | A string with the IP address of the network interface to bind to. This property is optional.
| `multicast` | A string with the IP address of a multicast address to bind to. This property is optional.
| `ttl` | A number with the multicast time-to-live value as a number from 1 to 255. This property is required if the `multicast` property is provided and otherwise ignored.

#### Methods

**`read()`**
The `read` call returns a complete UDP packet as an `ArrayBuffer`. The returned packet data has the following properties attached to it: 

- `address`, a string containing the packet sender's IP address
- `port`, the port number used to send the packet.

**`write(address, port, packet)`**
The `write` call takes three arguments: remote address string, remote port number, and the packet data as an `ArrayBuffer` or `TypedArray`. If there is insufficient memory to transmit the packet, the `write` call throws an exception.

#### Callbacks

**`onReadable(packets)`**

Invoked when one or more packets are received. The callback receives a single argument that indicates the total number of packets available to read.

#### Data Format
The data format is always `buffer`. The `write` call accepts an `ArrayBuffer` or a `TypedArray`. The `read` call always returns an `ArrayBuffer`.

<a id="io-providers"></a>
## 9 IO Providers Class Pattern

The IO Providers Class Pattern builds on the Base Class Pattern to provide a foundation to access a collection of IO Classes.

An IO Provider contains one or more IO Classes. The IO Provider may be connected to the host in any way, including:

- A direct hardware connection such as I²C or SPI
- A local wireless connection such as BLE using the Automation IO Service profile
- A TCP/IP connection to an internet cloud service

It is anticipated, but not required, that implementations of the IO Provider Class Pattern will perform IO using instances conforming to the IO Class Pattern. To facilitate that, the constructor uses IO constructor properties to specify their IO connections.

An IO Provider instance contains IO Classes which conform to the IO Class Pattern. The following code is an example of using an IO Provider to access a Digital pin on a GPIO expander connected with I²C.

```js
const expander = new Expander({
	data: 5,
	clock: 4,
	hz: 1_000_000,
	address: 0x20,
});

const led = new expander.Digital({
	pin: 13,
	mode: expander.Digital.Output,
});
led.write(1);
```
Here the `data` and `clock` pins passed to the `Expander` constructor refer to pins of the host whereas the `pin` passed to the `expander.Digital` constructor refers to a pin of the GPIO expander.

### `constructor`

Following the Base Class Pattern, the constructor has a single options object argument. The options object defines the hardware connections of the sensor. These use the same properties as the IO types corresponding to the hardware connection. Like the Sensor Class Pattern, the Provider Class Pattern, the IO properties are grouped to avoid collisions.

The options object is not limited to IO connection information, and may contain any information needed by the implementation to establish the connection.

### `close` Method
In addition to releasing all resources as required by the Base Class Pattern, the `close` method must invoke the `onError` callback on all open instances.

### `read` and `write` Methods

Unused. All IO is performed using instances of the IO Class of the IO Provider.

### Callbacks

**`onReady()`**

The `onReady` callback is invoked once the IO Provider instance is ready for use.

The IO provider may not know what IO resources are available until it has successfully established a connection to the remote resource. For this reason, a provider may not have any IO constructors on its instance until the `onReady` is invoked.

The IO constructors of an IO Provider may be called prior to `onReady` being invoked, if the implementation supports it.

**`onError()`**

Th `onError` callback is invoked on a non-recoverable error to indicate the provider instance can no longer be used.

When a provider fails, its IO instances also become unusable and consequently `onError` must also be invoked on each instance.

<a id="sensor-class-pattern"></a>
## 10 Sensor Class Pattern

The Sensor Class Pattern builds on the Base Class Pattern to provide a foundation for implementing access to a variety of sensors.

It is anticipated, but not required, that instances conforming to the Sensor Class Pattern will perform IO using instances conforming to the IO Class Pattern. The Sensor Class Pattern therefore are non-blocking, like IO. Additionally, the constructor uses IO constructor properties to specify their IO connections.

The Sensor Class Pattern provides low level sensor access, similar to a sensor driver provided by a sensor manufacturer, to support access to all the unique capabilities of the sensor. As with IO, where a given type of device (e.g. a temperature sensor) have common capabilities across manufacturers, the individual sensor types define a common way to access that functionality.

Higher level sensor APIs may be built using instances of the Sensor Class Pattern. The W3C Generic Sensor specification, for example, may be implemented using sensor conforming to The Sensor Class Pattern.

The Sensor Class Pattern may be used together with the Sensor Data Provence Rules to improve the usability of the data collected.

### `constructor`

Following the Base Class Pattern, the constructor has a single options object argument. The options object defines the hardware connections of the sensor. These use the same properties as the IO types corresponding to the hardware connection. For example, an I²C temperature sensor:

	let t = new Temperature({
		data: 4,
		clock: 5,
		address: 0x30
	});

If the sensor has multiple hardware connections the options object separates them to avoid collisions. For example, here the temperature sensor has an interrupt on a Digital pin:

	let t = new Temperature({
		sensor: {
			data: 4,
			clock: 5,
			address: 0x30
		},
		interrupt: {
			pin: 5
		}
	});

The constructor must reset the sensor hardware to a consistent initial state so the sensor's behavior is not dependent on a previous instantiation. This reset may include calling the instance's `configure` method.

### `configure` method

The `configure` method defines how the sensor operates. This may include the hardware's sampling interval, what data is sampled, and the range of the data sampled. 

The `configure` method has a single argument, an options object.

The `configure` method follows the same rules regarding the options argument as the `constructor` and therefore may not modify its content.

As sensors have many options, the `configure` method may implement support for many properties. A given call to `configure` method should only modify the configuration properties included in the options object. 

Calling the `configure` method is not required for use of the sensor when the default configuration is adequate.

The `configure` method may be called more than once to allow scripts to reconfigure the sensor.

### `sample` method

The `sample` method returns readings from the sensor. The Sensor Class Pattern defines no arguments for the `sample` method, though individual sensor types may.

The `sample` method returns an object containing one or more properties. The returned object is mutable. The implementation must return a different object on each invocation to allow calls to accumulate multiple sensor readings.

> Note: A sensor implementation of `sample` may accept an input argument of the object to use for the sensor data as an optimization to reduce memory manager work.

If the sample data includes one or more time stamps that indicate when the sample was collected, those timestamps in the returned sample object should conform to the Sensor Data Provence Rules.

<a id="sensor-classes"></a>
## 11 Sensor Classes

<a id="pixel-display-class-pattern"></a>
## 12 Pixel Display Class Pattern

<a id="sensor-data-provence-rules"></a>
## 13 Sensor Data Provence Rules

